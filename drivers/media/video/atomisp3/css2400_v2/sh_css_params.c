/*
* Support for Medfield PNW Camera Imaging ISP subsystem.
*
* Copyright (c) 2010 Intel Corporation. All Rights Reserved.
*
* Copyright (c) 2010 Silicon Hive www.siliconhive.com.
*
* This program is free software; you can redistribute it and/or
* modify it under the terms of the GNU General Public License version
* 2 as published by the Free Software Foundation.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
* 02110-1301, USA.
*
*/

#include "gdc_device.h"		/* gdc_lut_store(), ... */
#include "isp.h"			/* ISP_VEC_ELEMBITS */
#include "vamem.h"
#if !defined(HAS_NO_HMEM)
#ifndef __INLINE_HMEM__
#define __INLINE_HMEM__
#endif
#include "hmem.h"
#endif /* !defined(HAS_NO_HMEM) */
#include "queue.h"			/* host2sp_enqueue_frame_data() */
#include "sw_event.h"		/* encode_sw_event */

#include "assert_support.h"
#include "math_support.h"	/* max(), min() */

#include "sh_css_params.h"
#include "ia_css_stream.h"
#include "sh_css_params_internal.h"
#include "sh_css_param_shading.h"
#include "sh_css_param_dvs.h"
#include "sh_css_refcount.h"
#include "sh_css_internal.h"
#include "sh_css_defs.h"
#include "sh_css_sp.h"
#include "sh_css_sp_start.h"	/* SH_CSS_PREVENT_UNINIT_READS */
#include "sh_css_debug.h"
#include "memory_access.h"

#include "platform_support.h"

#define NOT_USED(a)                ((a) = (a))

#define sISP_REG_BIT		      ISP_VEC_ELEMBITS
#define uISP_REG_BIT		      ((unsigned)(sISP_REG_BIT-1))
#define sSHIFT				    (16-sISP_REG_BIT)
#define uSHIFT				    ((unsigned)(16-uISP_REG_BIT))
#define sFRACTION_BITS_FITTING(a) (a-sSHIFT)
#define uFRACTION_BITS_FITTING(a) ((unsigned)(a-uSHIFT))
#define sISP_VAL_MIN		      (-(1<<uISP_REG_BIT))
#define sISP_VAL_MAX		      ((1<<uISP_REG_BIT)-1)
#define uISP_VAL_MIN		      ((unsigned)0)
#define uISP_VAL_MAX		      ((unsigned)((1<<uISP_REG_BIT)-1))

/* Convenience macro to force a value to a lower even value.
 *  We do not want to (re)use the kernel macro round_down here
 *  because the same code base is used internally by Silicon Hive
 *  simulation environment, where the kernel macro is not available
 */
#define EVEN_FLOOR(x)	(x & ~1)

/* a:fraction bits for 16bit precision, b:fraction bits for ISP precision */
#define sDIGIT_FITTING(v, a, b) \
	min(max((((v)>>sSHIFT) >> (sFRACTION_BITS_FITTING(a)-(b))), \
	  sISP_VAL_MIN), sISP_VAL_MAX)
#define uDIGIT_FITTING(v, a, b) \
	min((unsigned)max((unsigned)(((v)>>uSHIFT) \
	>> (uFRACTION_BITS_FITTING(a)-(b))), \
	  uISP_VAL_MIN), uISP_VAL_MAX)

#define FPNTBL_BYTES(binary) \
	(sizeof(char) * (binary)->in_frame_info.res.height * \
	 (binary)->in_frame_info.padded_width)
#define SCTBL_BYTES(binary) \
	(sizeof(unsigned short) * (binary)->sctbl_height * \
	 (binary)->sctbl_aligned_width_per_color * IA_CSS_SC_NUM_COLORS)
#if 0
#define S3ATBL_BYTES(binary) \
	(sizeof(struct ia_css_3a_output) * (binary)->s3atbl_isp_width * \
	 (binary)->s3atbl_isp_height)
#endif
/* TODO: check if the stride is always the same max value or whether
 * it varies per resolution. */
#if 0
#define S3ATBL_HI_LO_BYTES(binary) \
	(ISP_S3ATBL_HI_LO_STRIDE_BYTES * (binary)->s3atbl_isp_height)
#endif
/* SDIS */
#define SDIS_VER_COEF_TBL__IN_DMEM(b) \
	_SDIS_VER_COEF_TBL_USE_DMEM(b->info->mode, b->info->enable.dis, b->info->isp_pipe_version)

#define SH_CSS_DIS_VER_NUM_COEF_TYPES(b) \
  (((b)->info->isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : \
	(SDIS_VER_COEF_TBL__IN_DMEM(b) ? \
		IA_CSS_DVS_COEF_TYPES_ON_DMEM : \
		IA_CSS_DVS_NUM_COEF_TYPES))

#define SDIS_HOR_COEF_TBL_BYTES(b) \
	(sizeof(short) * (((b)->info->isp_pipe_version == 2) ? IA_CSS_DVS2_NUM_COEF_TYPES : IA_CSS_DVS_NUM_COEF_TYPES) * (b)->dis_hor_coef_num_isp)
#define SDIS_VER_COEF_TBL_BYTES(b) \
	(sizeof(short) * SH_CSS_DIS_VER_NUM_COEF_TYPES(b) * \
		(b)->dis_ver_coef_num_isp)
#if 0
#define SDIS_HOR_PROJ_TBL_BYTES(b) \
	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_hor_proj_num_isp)
#define SDIS_VER_PROJ_TBL_BYTES(b) \
	(sizeof(int)   * IA_CSS_DVS_NUM_COEF_TYPES * (b)->dis_ver_proj_num_isp)
#endif
#define MORPH_PLANE_BYTES(binary) \
	(SH_CSS_MORPH_TABLE_ELEM_BYTES * (binary)->morph_tbl_aligned_width * \
	 (binary)->morph_tbl_height)

/* @GC TODO: Move these defines to the appropriate place later. */
#define DVS_BLOCKDIM_X (64)
#define DVS_BLOCKDIM_Y (64)
#define DVS_COORD_FRAC_BITS (10)
#define DVS_INPUT_BYTES_PER_PIXEL (1)
#define XMEM_ALIGN_LOG2 (5)

#define DVS_6AXIS_COORDS_ELEMS CEIL_MUL(sizeof(gdc_warp_param_mem_t) \
					, HIVE_ISP_DDR_WORD_BYTES)

#define DVS_6AXIS_BYTES(binary) \
	(DVS_6AXIS_COORDS_ELEMS \
	 * (binary)->out_frame_info.res.width / DVS_BLOCKDIM_X \
	 * (binary)->out_frame_info.res.height) / (DVS_BLOCKDIM_Y)


/* We keep a second copy of the ptr struct for the SP to access.
   Again, this would not be necessary on the chip. */
static hrt_vaddress sp_ddr_ptrs;

/* sp group address on DDR */
static hrt_vaddress xmem_sp_group_ptrs;

static hrt_vaddress xmem_sp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
						[SH_CSS_MAX_STAGES];
static hrt_vaddress xmem_isp_stage_ptrs[IA_CSS_PIPE_ID_NUM]
						[SH_CSS_MAX_STAGES];

/* END DO NOT MOVE INTO VIMALS_WORLD */

#if defined(HAS_VAMEM_VERSION_2)

static const uint16_t
default_gamma_table_data[IA_CSS_VAMEM_2_GAMMA_TABLE_SIZE] = {
  0,   4,   8,  12,  17,  21,  27,  32,
 38,  44,  49,  55,  61,  66,  71,  76,
 80,  84,  88,  92,  95,  98, 102, 105,
108, 110, 113, 116, 118, 121, 123, 126,
128, 130, 132, 135, 137, 139, 141, 143,
145, 146, 148, 150, 152, 153, 155, 156,
158, 160, 161, 162, 164, 165, 166, 168,
169, 170, 171, 172, 174, 175, 176, 177,
178, 179, 180, 181, 182, 183, 184, 184,
185, 186, 187, 188, 189, 189, 190, 191,
192, 192, 193, 194, 195, 195, 196, 197,
197, 198, 198, 199, 200, 200, 201, 201,
202, 203, 203, 204, 204, 205, 205, 206,
206, 207, 207, 208, 208, 209, 209, 210,
210, 210, 211, 211, 212, 212, 213, 213,
214, 214, 214, 215, 215, 216, 216, 216,
217, 217, 218, 218, 218, 219, 219, 220,
220, 220, 221, 221, 222, 222, 222, 223,
223, 223, 224, 224, 225, 225, 225, 226,
226, 226, 227, 227, 227, 228, 228, 228,
229, 229, 229, 230, 230, 230, 231, 231,
231, 232, 232, 232, 233, 233, 233, 234,
234, 234, 234, 235, 235, 235, 236, 236,
236, 237, 237, 237, 237, 238, 238, 238,
239, 239, 239, 239, 240, 240, 240, 241,
241, 241, 241, 242, 242, 242, 242, 243,
243, 243, 243, 244, 244, 244, 245, 245,
245, 245, 246, 246, 246, 246, 247, 247,
247, 247, 248, 248, 248, 248, 249, 249,
249, 249, 250, 250, 250, 250, 251, 251,
251, 251, 252, 252, 252, 252, 253, 253,
253, 253, 254, 254, 254, 254, 255, 255,
255
};

static const uint16_t
default_ctc_table_data[IA_CSS_VAMEM_2_CTC_TABLE_SIZE] = {
   0,  384,  837,  957, 1011, 1062, 1083, 1080,
1078, 1077, 1053, 1039, 1012,  992,  969,  951,
 929,  906,  886,  866,  845,  823,  809,  790,
 772,  758,  741,  726,  711,  701,  688,  675,
 666,  656,  648,  639,  633,  626,  618,  612,
 603,  594,  582,  572,  557,  545,  529,  516,
 504,  491,  480,  467,  459,  447,  438,  429,
 419,  412,  404,  397,  389,  382,  376,  368,
 363,  357,  351,  345,  340,  336,  330,  326,
 321,  318,  312,  308,  304,  300,  297,  294,
 291,  286,  284,  281,  278,  275,  271,  268,
 261,  257,  251,  245,  240,  235,  232,  225,
 223,  218,  213,  209,  206,  204,  199,  197,
 193,  189,  186,  185,  183,  179,  177,  175,
 172,  170,  169,  167,  164,  164,  162,  160,
 158,  157,  156,  154,  154,  152,  151,  150,
 149,  148,  146,  147,  146,  144,  143,  143,
 142,  141,  140,  141,  139,  138,  138,  138,
 137,  136,  136,  135,  134,  134,  134,  133,
 132,  132,  131,  130,  131,  130,  129,  128,
 129,  127,  127,  127,  127,  125,  125,  125,
 123,  123,  122,  120,  118,  115,  114,  111,
 110,  108,  106,  105,  103,  102,  100,   99,
  97,   97,   96,   95,   94,   93,   93,   91,
  91,   91,   90,   90,   89,   89,   88,   88,
  89,   88,   88,   87,   87,   87,   87,   86,
  87,   87,   86,   87,   86,   86,   84,   84,
  82,   80,   78,   76,   74,   72,   70,   68,
  67,   65,   62,   60,   58,   56,   55,   54,
  53,   51,   49,   49,   47,   45,   45,   45,
  41,   40,   39,   39,   34,   33,   34,   32,
  25,   23,   24,   20,   13,    9,   12,    0,
   0
};

static const uint16_t
default_r_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
   0,   72,  144,  216,  288,  360,  426,  486,
 541,  592,  641,  687,  730,  772,  812,  850,
 887,  923,  958,  991, 1024, 1055, 1086, 1117,
1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
4095
};

static const uint16_t
default_g_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
   0,   72,  144,  216,  288,  360,  426,  486,
 541,  592,  641,  687,  730,  772,  812,  850,
 887,  923,  958,  991, 1024, 1055, 1086, 1117,
1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
4095
};

static const uint16_t
default_b_gamma_table_data[IA_CSS_VAMEM_2_RGB_GAMMA_TABLE_SIZE] = {
   0,   72,  144,  216,  288,  360,  426,  486,
 541,  592,  641,  687,  730,  772,  812,  850,
 887,  923,  958,  991, 1024, 1055, 1086, 1117,
1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088,
4095
};

static const uint16_t
default_xnr_table_data[IA_CSS_VAMEM_2_XNR_TABLE_SIZE] = {
  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
  8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
    546>>1, 512>>1,

  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
    256>>1,

  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
    170>>1,

  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1
};

#elif defined(HAS_VAMEM_VERSION_1)

/* Default Parameters */
static const uint16_t
default_gamma_table_data[IA_CSS_VAMEM_1_GAMMA_TABLE_SIZE] = {
		0, 1, 2, 3, 4, 5, 6, 7,
		8, 9, 10, 11, 12, 13, 14, 16,
		17, 18, 19, 20, 21, 23, 24, 25,
		27, 28, 29, 31, 32, 33, 35, 36,
		38, 39, 41, 42, 44, 45, 47, 48,
		49, 51, 52, 54, 55, 57, 58, 60,
		61, 62, 64, 65, 66, 68, 69, 70,
		71, 72, 74, 75, 76, 77, 78, 79,
		80, 81, 82, 83, 84, 85, 86, 87,
		88, 89, 90, 91, 92, 93, 93, 94,
		95, 96, 97, 98, 98, 99, 100, 101,
		102, 102, 103, 104, 105, 105, 106, 107,
		108, 108, 109, 110, 110, 111, 112, 112,
		113, 114, 114, 115, 116, 116, 117, 118,
		118, 119, 120, 120, 121, 121, 122, 123,
		123, 124, 125, 125, 126, 126, 127, 127,	/* 128 */
		128, 129, 129, 130, 130, 131, 131, 132,
		132, 133, 134, 134, 135, 135, 136, 136,
		137, 137, 138, 138, 139, 139, 140, 140,
		141, 141, 142, 142, 143, 143, 144, 144,
		145, 145, 145, 146, 146, 147, 147, 148,
		148, 149, 149, 150, 150, 150, 151, 151,
		152, 152, 152, 153, 153, 154, 154, 155,
		155, 155, 156, 156, 156, 157, 157, 158,
		158, 158, 159, 159, 160, 160, 160, 161,
		161, 161, 162, 162, 162, 163, 163, 163,
		164, 164, 164, 165, 165, 165, 166, 166,
		166, 167, 167, 167, 168, 168, 168, 169,
		169, 169, 170, 170, 170, 170, 171, 171,
		171, 172, 172, 172, 172, 173, 173, 173,
		174, 174, 174, 174, 175, 175, 175, 176,
		176, 176, 176, 177, 177, 177, 177, 178,	/* 256 */
		178, 178, 178, 179, 179, 179, 179, 180,
		180, 180, 180, 181, 181, 181, 181, 182,
		182, 182, 182, 182, 183, 183, 183, 183,
		184, 184, 184, 184, 184, 185, 185, 185,
		185, 186, 186, 186, 186, 186, 187, 187,
		187, 187, 187, 188, 188, 188, 188, 188,
		189, 189, 189, 189, 189, 190, 190, 190,
		190, 190, 191, 191, 191, 191, 191, 192,
		192, 192, 192, 192, 192, 193, 193, 193,
		193, 193, 194, 194, 194, 194, 194, 194,
		195, 195, 195, 195, 195, 195, 196, 196,
		196, 196, 196, 196, 197, 197, 197, 197,
		197, 197, 198, 198, 198, 198, 198, 198,
		198, 199, 199, 199, 199, 199, 199, 200,
		200, 200, 200, 200, 200, 200, 201, 201,
		201, 201, 201, 201, 201, 202, 202, 202,	/* 384 */
		202, 202, 202, 202, 203, 203, 203, 203,
		203, 203, 203, 204, 204, 204, 204, 204,
		204, 204, 204, 205, 205, 205, 205, 205,
		205, 205, 205, 206, 206, 206, 206, 206,
		206, 206, 206, 207, 207, 207, 207, 207,
		207, 207, 207, 208, 208, 208, 208, 208,
		208, 208, 208, 209, 209, 209, 209, 209,
		209, 209, 209, 209, 210, 210, 210, 210,
		210, 210, 210, 210, 210, 211, 211, 211,
		211, 211, 211, 211, 211, 211, 212, 212,
		212, 212, 212, 212, 212, 212, 212, 213,
		213, 213, 213, 213, 213, 213, 213, 213,
		214, 214, 214, 214, 214, 214, 214, 214,
		214, 214, 215, 215, 215, 215, 215, 215,
		215, 215, 215, 216, 216, 216, 216, 216,
		216, 216, 216, 216, 216, 217, 217, 217,	/* 512 */
		217, 217, 217, 217, 217, 217, 217, 218,
		218, 218, 218, 218, 218, 218, 218, 218,
		218, 219, 219, 219, 219, 219, 219, 219,
		219, 219, 219, 220, 220, 220, 220, 220,
		220, 220, 220, 220, 220, 221, 221, 221,
		221, 221, 221, 221, 221, 221, 221, 221,
		222, 222, 222, 222, 222, 222, 222, 222,
		222, 222, 223, 223, 223, 223, 223, 223,
		223, 223, 223, 223, 223, 224, 224, 224,
		224, 224, 224, 224, 224, 224, 224, 224,
		225, 225, 225, 225, 225, 225, 225, 225,
		225, 225, 225, 226, 226, 226, 226, 226,
		226, 226, 226, 226, 226, 226, 226, 227,
		227, 227, 227, 227, 227, 227, 227, 227,
		227, 227, 228, 228, 228, 228, 228, 228,
		228, 228, 228, 228, 228, 228, 229, 229,
		229, 229, 229, 229, 229, 229, 229, 229,
		229, 229, 230, 230, 230, 230, 230, 230,
		230, 230, 230, 230, 230, 230, 231, 231,
		231, 231, 231, 231, 231, 231, 231, 231,
		231, 231, 231, 232, 232, 232, 232, 232,
		232, 232, 232, 232, 232, 232, 232, 233,
		233, 233, 233, 233, 233, 233, 233, 233,
		233, 233, 233, 233, 234, 234, 234, 234,
		234, 234, 234, 234, 234, 234, 234, 234,
		234, 235, 235, 235, 235, 235, 235, 235,
		235, 235, 235, 235, 235, 235, 236, 236,
		236, 236, 236, 236, 236, 236, 236, 236,
		236, 236, 236, 236, 237, 237, 237, 237,
		237, 237, 237, 237, 237, 237, 237, 237,
		237, 237, 238, 238, 238, 238, 238, 238,
		238, 238, 238, 238, 238, 238, 238, 238,
		239, 239, 239, 239, 239, 239, 239, 239,
		239, 239, 239, 239, 239, 239, 240, 240,
		240, 240, 240, 240, 240, 240, 240, 240,
		240, 240, 240, 240, 241, 241, 241, 241,
		241, 241, 241, 241, 241, 241, 241, 241,
		241, 241, 241, 242, 242, 242, 242, 242,
		242, 242, 242, 242, 242, 242, 242, 242,
		242, 242, 243, 243, 243, 243, 243, 243,
		243, 243, 243, 243, 243, 243, 243, 243,
		243, 244, 244, 244, 244, 244, 244, 244,
		244, 244, 244, 244, 244, 244, 244, 244,
		245, 245, 245, 245, 245, 245, 245, 245,
		245, 245, 245, 245, 245, 245, 245, 246,
		246, 246, 246, 246, 246, 246, 246, 246,
		246, 246, 246, 246, 246, 246, 246, 247,
		247, 247, 247, 247, 247, 247, 247, 247,
		247, 247, 247, 247, 247, 247, 247, 248,
		248, 248, 248, 248, 248, 248, 248, 248,
		248, 248, 248, 248, 248, 248, 248, 249,
		249, 249, 249, 249, 249, 249, 249, 249,
		249, 249, 249, 249, 249, 249, 249, 250,
		250, 250, 250, 250, 250, 250, 250, 250,
		250, 250, 250, 250, 250, 250, 250, 251,
		251, 251, 251, 251, 251, 251, 251, 251,
		251, 251, 251, 251, 251, 251, 251, 252,
		252, 252, 252, 252, 252, 252, 252, 252,
		252, 252, 252, 252, 252, 252, 252, 253,
		253, 253, 253, 253, 253, 253, 253, 253,
		253, 253, 253, 253, 253, 253, 253, 253,
		254, 254, 254, 254, 254, 254, 254, 254,
		254, 254, 254, 254, 254, 254, 254, 254,
		255, 255, 255, 255, 255, 255, 255, 255
};

static const uint16_t
default_ctc_table_data[IA_CSS_VAMEM_1_CTC_TABLE_SIZE] = {
		0, 0, 256, 384, 384, 497, 765, 806,
		837, 851, 888, 901, 957, 981, 993, 1001,
		1011, 1029, 1028, 1039, 1062, 1059, 1073, 1080,
		1083, 1085, 1085, 1098, 1080, 1084, 1085, 1093,
		1078, 1073, 1070, 1069, 1077, 1066, 1072, 1063,
		1053, 1044, 1046, 1053, 1039, 1028, 1025, 1024,
		1012, 1013, 1016, 996, 992, 990, 990, 980,
		969, 968, 961, 955, 951, 949, 933, 930,
		929, 925, 921, 916, 906, 901, 895, 893,
		886, 877, 872, 869, 866, 861, 857, 849,
		845, 838, 836, 832, 823, 821, 815, 813,
		809, 805, 796, 793, 790, 785, 784, 778,
		772, 768, 766, 763, 758, 752, 749, 745,
		741, 740, 736, 730, 726, 724, 723, 718,
		711, 709, 706, 704, 701, 698, 691, 689,
		688, 683, 683, 678, 675, 673, 671, 669,
		666, 663, 661, 660, 656, 656, 653, 650,
		648, 647, 646, 643, 639, 638, 637, 635,
		633, 632, 629, 627, 626, 625, 622, 621,
		618, 618, 614, 614, 612, 609, 606, 606,
		603, 600, 600, 597, 594, 591, 590, 586,
		582, 581, 578, 575, 572, 569, 563, 560,
		557, 554, 551, 548, 545, 539, 536, 533,
		529, 527, 524, 519, 516, 513, 510, 507,
		504, 501, 498, 493, 491, 488, 485, 484,
		480, 476, 474, 471, 467, 466, 464, 460,
		459, 455, 453, 449, 447, 446, 443, 441,
		438, 435, 432, 432, 429, 427, 426, 422,
		419, 418, 416, 414, 412, 410, 408, 406,
		404, 402, 401, 398, 397, 395, 393, 390,
		389, 388, 387, 384, 382, 380, 378, 377,
		376, 375, 372, 370, 368, 368, 366, 364,
		363, 361, 360, 358, 357, 355, 354, 352,
		351, 350, 349, 346, 345, 344, 344, 342,
		340, 339, 337, 337, 336, 335, 333, 331,
		330, 329, 328, 326, 326, 324, 324, 322,
		321, 320, 318, 318, 318, 317, 315, 313,
		312, 311, 311, 310, 308, 307, 306, 306,
		304, 304, 302, 301, 300, 300, 299, 297,
		297, 296, 296, 294, 294, 292, 291, 291,
		291, 290, 288, 287, 286, 286, 287, 285,
		284, 283, 282, 282, 281, 281, 279, 278,
		278, 278, 276, 276, 275, 274, 274, 273,
		271, 270, 269, 268, 268, 267, 265, 262,
		261, 260, 260, 259, 257, 254, 252, 252,
		251, 251, 249, 246, 245, 244, 243, 242,
		240, 239, 239, 237, 235, 235, 233, 231,
		232, 230, 229, 226, 225, 224, 225, 224,
		223, 220, 219, 219, 218, 217, 217, 214,
		213, 213, 212, 211, 209, 209, 209, 208,
		206, 205, 204, 203, 204, 203, 201, 200,
		199, 197, 198, 198, 197, 195, 194, 194,
		193, 192, 192, 191, 189, 190, 189, 188,
		186, 187, 186, 185, 185, 184, 183, 181,
		183, 182, 181, 180, 179, 178, 178, 178,
		177, 176, 175, 176, 175, 174, 174, 173,
		172, 173, 172, 171, 170, 170, 169, 169,
		169, 168, 167, 166, 167, 167, 166, 165,
		164, 164, 164, 163, 164, 163, 162, 163,
		162, 161, 160, 161, 160, 160, 160, 159,
		158, 157, 158, 158, 157, 157, 156, 156,
		156, 156, 155, 155, 154, 154, 154, 154,
		154, 153, 152, 153, 152, 152, 151, 152,
		151, 152, 151, 150, 150, 149, 149, 150,
		149, 149, 148, 148, 148, 149, 148, 147,
		146, 146, 147, 146, 147, 146, 145, 146,
		146, 145, 144, 145, 144, 145, 144, 144,
		143, 143, 143, 144, 143, 142, 142, 142,
		142, 142, 142, 141, 141, 141, 141, 140,
		140, 141, 140, 140, 141, 140, 139, 139,
		139, 140, 139, 139, 138, 138, 137, 139,
		138, 138, 138, 137, 138, 137, 137, 137,
		137, 136, 137, 136, 136, 136, 136, 135,
		136, 135, 135, 135, 135, 136, 135, 135,
		134, 134, 133, 135, 134, 134, 134, 133,
		134, 133, 134, 133, 133, 132, 133, 133,
		132, 133, 132, 132, 132, 132, 131, 131,
		131, 132, 131, 131, 130, 131, 130, 132,
		131, 130, 130, 129, 130, 129, 130, 129,
		129, 129, 130, 129, 128, 128, 128, 128,
		129, 128, 128, 127, 127, 128, 128, 127,
		127, 126, 126, 127, 127, 126, 126, 126,
		127, 126, 126, 126, 125, 125, 126, 125,
		125, 124, 124, 124, 125, 125, 124, 124,
		123, 124, 124, 123, 123, 122, 122, 122,
		122, 122, 121, 120, 120, 119, 118, 118,
		118, 117, 117, 116, 115, 115, 115, 114,
		114, 113, 113, 112, 111, 111, 111, 110,
		110, 109, 109, 108, 108, 108, 107, 107,
		106, 106, 105, 105, 105, 104, 104, 103,
		103, 102, 102, 102, 102, 101, 101, 100,
		100, 99, 99, 99, 99, 99, 99, 98,
		97, 98, 97, 97, 97, 96, 96, 95,
		96, 95, 96, 95, 95, 94, 94, 95,
		94, 94, 94, 93, 93, 92, 93, 93,
		93, 93, 92, 92, 91, 92, 92, 92,
		91, 91, 90, 90, 91, 91, 91, 90,
		90, 90, 90, 91, 90, 90, 90, 89,
		89, 89, 90, 89, 89, 89, 89, 89,
		88, 89, 89, 88, 88, 88, 88, 87,
		89, 88, 88, 88, 88, 88, 87, 88,
		88, 88, 87, 87, 87, 87, 87, 88,
		87, 87, 87, 87, 87, 87, 88, 87,
		87, 87, 87, 86, 86, 87, 87, 87,
		87, 86, 86, 86, 87, 87, 86, 87,
		86, 86, 86, 87, 87, 86, 86, 86,
		86, 86, 87, 87, 86, 85, 85, 85,
		84, 85, 85, 84, 84, 83, 83, 82,
		82, 82, 81, 81, 80, 79, 79, 79,
		78, 77, 77, 76, 76, 76, 75, 74,
		74, 74, 73, 73, 72, 71, 71, 71,
		70, 70, 69, 69, 68, 68, 67, 67,
		67, 66, 66, 65, 65, 64, 64, 63,
		62, 62, 62, 61, 60, 60, 59, 59,
		58, 58, 57, 57, 56, 56, 56, 55,
		55, 54, 55, 55, 54, 53, 53, 52,
		53, 53, 52, 51, 51, 50, 51, 50,
		49, 49, 50, 49, 49, 48, 48, 47,
		47, 48, 46, 45, 45, 45, 46, 45,
		45, 44, 45, 45, 45, 43, 42, 42,
		41, 43, 41, 40, 40, 39, 40, 41,
		39, 39, 39, 39, 39, 38, 35, 35,
		34, 37, 36, 34, 33, 33, 33, 35,
		34, 32, 32, 31, 32, 30, 29, 26,
		25, 25, 27, 26, 23, 23, 23, 25,
		24, 24, 22, 21, 20, 19, 16, 14,
		13, 13, 13, 10, 9, 7, 7, 7,
		12, 12, 12, 7, 0, 0, 0, 0
};

static const uint16_t
default_r_gamma_table_data[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE] = {
   0,   72,  144,  216,  288,  360,  426,  486,
 541,  592,  641,  687,  730,  772,  812,  850,
 887,  923,  958,  991, 1024, 1055, 1086, 1117,
1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088
};

static const uint16_t
default_g_gamma_table_data[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE] = {
   0,   72,  144,  216,  288,  360,  426,  486,
 541,  592,  641,  687,  730,  772,  812,  850,
 887,  923,  958,  991, 1024, 1055, 1086, 1117,
1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088
};

static const uint16_t
default_b_gamma_table_data[IA_CSS_VAMEM_1_RGB_GAMMA_TABLE_SIZE] = {
   0,   72,  144,  216,  288,  360,  426,  486,
 541,  592,  641,  687,  730,  772,  812,  850,
 887,  923,  958,  991, 1024, 1055, 1086, 1117,
1146, 1175, 1203, 1230, 1257, 1284, 1310, 1335,
1360, 1385, 1409, 1433, 1457, 1480, 1502, 1525,
1547, 1569, 1590, 1612, 1632, 1653, 1674, 1694,
1714, 1734, 1753, 1772, 1792, 1811, 1829, 1848,
1866, 1884, 1902, 1920, 1938, 1955, 1973, 1990,
2007, 2024, 2040, 2057, 2074, 2090, 2106, 2122,
2138, 2154, 2170, 2185, 2201, 2216, 2231, 2247,
2262, 2277, 2291, 2306, 2321, 2335, 2350, 2364,
2378, 2393, 2407, 2421, 2435, 2449, 2462, 2476,
2490, 2503, 2517, 2530, 2543, 2557, 2570, 2583,
2596, 2609, 2622, 2634, 2647, 2660, 2673, 2685,
2698, 2710, 2722, 2735, 2747, 2759, 2771, 2783,
2795, 2807, 2819, 2831, 2843, 2855, 2867, 2878,
2890, 2901, 2913, 2924, 2936, 2947, 2958, 2970,
2981, 2992, 3003, 3014, 3025, 3036, 3047, 3058,
3069, 3080, 3091, 3102, 3112, 3123, 3134, 3144,
3155, 3165, 3176, 3186, 3197, 3207, 3217, 3228,
3238, 3248, 3258, 3268, 3279, 3289, 3299, 3309,
3319, 3329, 3339, 3349, 3358, 3368, 3378, 3388,
3398, 3407, 3417, 3427, 3436, 3446, 3455, 3465,
3474, 3484, 3493, 3503, 3512, 3521, 3531, 3540,
3549, 3559, 3568, 3577, 3586, 3595, 3605, 3614,
3623, 3632, 3641, 3650, 3659, 3668, 3677, 3686,
3694, 3703, 3712, 3721, 3730, 3739, 3747, 3756,
3765, 3773, 3782, 3791, 3799, 3808, 3816, 3825,
3833, 3842, 3850, 3859, 3867, 3876, 3884, 3893,
3901, 3909, 3918, 3926, 3934, 3942, 3951, 3959,
3967, 3975, 3984, 3992, 4000, 4008, 4016, 4024,
4032, 4040, 4048, 4056, 4064, 4072, 4080, 4088
};

static const uint16_t
default_xnr_table_data[IA_CSS_VAMEM_1_XNR_TABLE_SIZE] = {
  /* 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 */
  8191>>1, 4096>>1, 2730>>1, 2048>>1, 1638>>1, 1365>>1, 1170>>1, 1024>>1, 910>>1, 819>>1, 744>>1, 682>>1, 630>>1, 585>>1,
    546>>1, 512>>1,

  /* 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 */
  481>>1, 455>>1, 431>>1, 409>>1, 390>>1, 372>>1, 356>>1, 341>>1, 327>>1, 315>>1, 303>>1, 292>>1, 282>>1, 273>>1, 264>>1,
    256>>1,

  /* 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 */
  248>>1, 240>>1, 234>>1, 227>>1, 221>>1, 215>>1, 210>>1, 204>>1, 199>>1, 195>>1, 190>>1, 186>>1, 182>>1, 178>>1, 174>>1,
    170>>1,

  /* 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 */
  167>>1, 163>>1, 160>>1, 157>>1, 154>>1, 151>>1, 148>>1, 146>>1, 143>>1, 141>>1, 138>>1, 136>>1, 134>>1, 132>>1, 130>>1, 128>>1
};

#else
#error "sh_css_params.c: VAMEM version must \
	be one of {VAMEM_VERSION_1, VAMEM_VERSION_2}"
#endif

static struct ia_css_gamma_table     default_gamma_table;
static struct ia_css_ctc_table       default_ctc_table;
static struct ia_css_xnr_table       default_xnr_table;
static struct ia_css_rgb_gamma_table default_r_gamma_table;
static struct ia_css_rgb_gamma_table default_g_gamma_table;
static struct ia_css_rgb_gamma_table default_b_gamma_table;

#if 1
static const struct ia_css_anr_thres default_anr_thres = {
{128, 384, 640, 896, 896, 640, 384, 128, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 896, 2688, 4480, 6272, 6272, 4480, 2688, 896, 640, 1920, 3200, 4480, 4480, 3200, 1920, 640, 384, 1152, 1920, 2688, 2688, 1920, 1152, 384, 128, 384, 640, 896, 896, 640, 384, 128,
0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20, 0, 0, 30, 30, 10, 10, 20, 20,
0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40, 0, 0, 60, 60, 20, 20, 40, 40,
0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60, 0, 0, 90, 90, 30, 30, 60, 60,
30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50, 30, 30, 60, 60, 40, 40, 50, 50,
60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100, 60, 60, 120, 120, 80, 80, 100, 100,
90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150, 90, 90, 180, 180, 120, 120, 150, 150,
10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30, 10, 10, 40, 40, 20, 20, 30, 30,
20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60, 20, 20, 80, 80, 40, 40, 60, 60,
30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90, 30, 30, 120, 120, 60, 60, 90, 90,
20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40, 20, 20, 50, 50, 30, 30, 40, 40,
40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80, 40, 40, 100, 100, 60, 60, 80, 80,
60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120, 60, 60, 150, 150, 90, 90, 120, 120}
};
#else
static const struct ia_css_anr_thres default_anr_thres = {
{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};
#endif

/* multiple axis color correction table,
 * 64values = 2x2matrix for 16area, [s2.11].
 */
static const struct ia_css_macc_table default_macc_table = {
		{ 8192, 0, 0, 8192, 8192, 0, 0, 8192,
		8192, 0, 0, 8192, 8192, 0, 0, 8192,
		8192, 0, 0, 8192, 8192, 0, 0, 8192,
		8192, 0, 0, 8192, 8192, 0, 0, 8192,
		8192, 0, 0, 8192, 8192, 0, 0, 8192,
		8192, 0, 0, 8192, 8192, 0, 0, 8192,
		8192, 0, 0, 8192, 8192, 0, 0, 8192,
		8192, 0, 0, 8192, 8192, 0, 0, 8192 }
};

/* Digital Zoom lookup table. See documentation for more details about the
 * contents of this table.
 */
#if defined(HAS_GDC_VERSION_2)
static const int zoom_table[4][HRT_GDC_N] = {
		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,  -7<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4},
		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
	 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4},
	{256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
		 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4, 256<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4, 255<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4, 254<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4, 253<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4, 252<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4, 250<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4, 248<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4, 246<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4, 244<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4, 241<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4, 239<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4, 236<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4, 232<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4, 229<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4, 225<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4, 222<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4, 218<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4, 213<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4, 209<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4, 205<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4, 200<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4, 195<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4, 191<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4, 186<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4, 181<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4, 176<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4, 170<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4, 165<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4, 160<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4, 154<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4, 149<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4, 144<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4, 138<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4, 132<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4, 127<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4, 121<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4, 116<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4, 110<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4, 105<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,  99<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,  94<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,  88<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,  83<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,  78<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,  73<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,  67<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,  62<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,  58<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,  53<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,  48<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,  43<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,  39<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,  35<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,  31<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,  27<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,  23<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,  19<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,  16<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,  12<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,   9<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,   7<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,   4<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,
		  2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4,   2<<4},
		 {0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
		-10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4, -10<<4,
	    -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4, -19<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4, -18<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4, -17<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
	    -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4, -16<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4, -15<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4, -14<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4, -13<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4, -12<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		-11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4, -11<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,  -9<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,  -8<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
	     -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,  -6<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,  -5<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,  -4<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,  -3<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,  -2<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		 -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,  -1<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
		  1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,   1<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,
		  0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4,   0<<4}
};
#elif defined(HAS_GDC_VERSION_1)
static const int zoom_table[4][HRT_GDC_N] = {
	{0, 0, 0, 0, 0, 0, -1, -1,
	 -1, -2, -2, -3, -3, -4, -4, -5,
	 -6, -6, -7, -7, -8, -9, -9, -10,
	 -11, -11, -12, -13, -13, -14, -14, -15,
	 -16, -16, -16, -17, -17, -18, -18, -18,
	 -18, -18, -18, -18, -18, -18, -18, -18,
	 -18, -17, -17, -16, -15, -15, -14, -13,
	 -12, -11, -9, -8, -7, -5, -3, -1},
	{0, 2, 4, 7, 9, 12, 16, 19,
	 23, 27, 31, 35, 39, 43, 48, 53,
	 58, 62, 67, 73, 78, 83, 88, 94,
	 99, 105, 110, 116, 121, 127, 132, 138,
	 144, 149, 154, 160, 165, 170, 176, 181,
	 186, 191, 195, 200, 205, 209, 213, 218,
	 222, 225, 229, 232, 236, 239, 241, 244,
	 246, 248, 250, 252, 253, 254, 255, 255},
	{256, 255, 255, 254, 253, 252, 250, 248,
	 246, 244, 241, 239, 236, 232, 229, 225,
	 222, 218, 213, 209, 205, 200, 195, 191,
	 186, 181, 176, 170, 165, 160, 154, 149,
	 144, 138, 132, 127, 121, 116, 110, 105,
	 99, 94, 88, 83, 78, 73, 67, 62,
	 58, 53, 48, 43, 39, 35, 31, 27,
	 23, 19, 16, 12, 9, 7, 4, 2},
	{0, -1, -3, -5, -6, -8, -9, -10,
	 -12, -13, -14, -15, -16, -15, -17, -17,
	 -18, -18, -17, -19, -19, -18, -18, -19,
	 -18, -19, -18, -17, -17, -17, -16, -16,
	 -16, -15, -14, -14, -13, -12, -12, -12,
	 -11, -11, -9, -9, -9, -8, -6, -6,
	 -6, -5, -4, -3, -4, -3, -2, -2,
	 -1, 0, -1, 0, 1, 0, 0, 0}
};
#else
#error "sh_css_params.c: GDC version must be \
	one of {GDC_VERSION_1, GDC_VERSION_2}"
#endif

static const struct ia_css_3a_config default_3a_config = {
	25559,
	32768,
	7209,
	65535,
	0,
	65535,
	{-3344, -6104, -19143, 19143, 6104, 3344, 0},
	{1027, 0, -9219, 16384, -9219, 1027, 0}
};

static const struct ia_css_wb_config default_wb_config = {
	1,
	32768,
	32768,
	32768,
	32768
};

static const struct ia_css_cc_config default_cc_config = {
	8,
	{255, 29, 120, 0, -374, -342, 0, -672, 301},
};

static const struct ia_css_tnr_config default_tnr_config = {
	32768,
	32,
	32,
};

static const struct ia_css_ob_config default_ob_config = {
	IA_CSS_OB_MODE_NONE,
	0,
	0,
	0,
	0,
	0,
	0
};

static const struct ia_css_dp_config default_dp_config = {
	8192,
	2048
};

static const struct ia_css_nr_config default_nr_config = {
	16384,
	8192,
	1280,
	0,
	0
};

static const struct ia_css_ee_config default_ee_config = {
	8192,
	128,
	2048
};

static const struct ia_css_de_config default_de_config = {
	0,
	0,
	0
};

static const struct ia_css_gc_config default_gc_config = {
	0,
	0
};

static const struct ia_css_anr_config default_anr_config = {
	10,
	{ 0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4,
	  0, 3, 1, 2, 3, 6, 4, 5, 1, 4, 2, 3, 2, 5, 3, 4},
	{10, 20, 30}
};

static const struct ia_css_ce_config default_ce_config = {
	0,
	255
};

static const struct ia_css_dz_config default_dz_config = {
	HRT_GDC_N,
	HRT_GDC_N
};

static const struct ia_css_vector default_motion_config = {
	0,
	0
};

static const struct ia_css_ecd_config default_ecd_config = {
	(1 << (ISP_VEC_ELEMBITS - 1)) * 2 / 3,	/* 2/3 */
	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1.0 */
	0,					/* 0.0 */
};

static const struct ia_css_ynr_config default_ynr_config = {
	0,
	0,
	0,
	0,
};

static const struct ia_css_fc_config default_fc_config = {
	1,
	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
	(1 << (ISP_VEC_ELEMBITS - 2)),		/* 0.5 */
	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
	(1 << (ISP_VEC_ELEMBITS - 1)) - 1,	/* 1 */
	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
	- (1 << (ISP_VEC_ELEMBITS - 1)),	/* -1 */
};

static const struct ia_css_cnr_config default_cnr_config = {
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0
};

static const struct ia_css_macc_config default_macc_config = {
	0,
};

static const struct ia_css_ctc_config default_ctc_config = {
	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
	((1 << IA_CSS_CTC_COEF_SHIFT) + 1) / 2,		/* 0.5 */
	1,
	SH_CSS_BAYER_MAXVAL / 5,	/* To be implemented */
	SH_CSS_BAYER_MAXVAL * 2 / 5,	/* To be implemented */
	SH_CSS_BAYER_MAXVAL * 3 / 5,	/* To be implemented */
	SH_CSS_BAYER_MAXVAL * 4 / 5,	/* To be implemented */
};

static const struct ia_css_aa_config default_aa_config = {
	8191,
};

/*static const struct ia_css_yuv2rgb_cc_config */
static const struct ia_css_cc_config default_yuv2rgb_cc_config = {
	SH_CSS_YUV2RGB_CCM_CALC_SHIFT,
	/* Bits of fractional part = SH_CSS_YUV2RGB_CCM_COEF_SHIFT = 12 */
	{4096, -4096, 4096, 4096, 4096, 0, 4096, -4096, -4096}
};

static const struct ia_css_cc_config default_rgb2yuv_cc_config = {
	SH_CSS_RGB2YUV_CSC_COEF_SHIFT,
	/* Bits of fractional part = SH_CSS_RGB2YUV_CSC_COEF_SHIFT = 13 */
	{2449, 4809, 934, -1382, -2714, 4096, 4096, -3430, -666}
};

static void
sh_css_dequeue_param_buffers(void);

static enum ia_css_err
ref_sh_css_ddr_address_map(
		struct sh_css_ddr_address_map *map,
		struct sh_css_ddr_address_map *out);

static enum ia_css_err
write_sh_css_address_map_to_ddr(
		struct sh_css_ddr_address_map *map,
		hrt_vaddress *out);

static enum ia_css_err
free_sh_css_ddr_address_map(hrt_vaddress ptr);

static enum ia_css_err
sh_css_params_write_to_ddr_internal(
		struct ia_css_isp_parameters *params,
		const struct sh_css_binary *binary,
		struct sh_css_ddr_address_map *ddr_map,
		struct sh_css_ddr_address_map_size *ddr_map_size);

static void
ia_css_set_dvs_coefficients(struct ia_css_isp_parameters *params,
				const struct ia_css_dvs_coefficients *coefs)
{
	assert(coefs);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dis_coefficients() enter: \
		hcoef=%p, vcoef=%p", coefs->hor_coefs, coefs->ver_coefs);
	params->dis_hor_coef_tbl = coefs->hor_coefs;
	params->dis_ver_coef_tbl = coefs->ver_coefs;
	params->dis_coef_table_changed = true;
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dis_coefficients() leave: void\n");
}

void
ia_css_get_dvs_statistics(struct ia_css_dvs_statistics           *host_stats,
			  const struct ia_css_isp_dvs_statistics *isp_stats)
{
	unsigned int hor_num_isp, ver_num_isp,
#ifndef __KERNEL__
		     hor_bytes, ver_bytes;
#else
		     hor_num_dvs, ver_num_dvs, i;
#endif
	int *hor_ptr_dvs,
	    *ver_ptr_dvs;
	hrt_vaddress hor_ptr_isp,
		     ver_ptr_isp;

	assert(host_stats);
	assert(host_stats->hor_proj);
	assert(host_stats->ver_proj);
	assert(isp_stats);
	assert(isp_stats->hor_proj);
	assert(isp_stats->ver_proj);

	hor_num_isp = host_stats->grid.aligned_height;
	ver_num_isp = host_stats->grid.aligned_width;
	hor_ptr_isp = isp_stats->hor_proj;
	ver_ptr_isp = isp_stats->ver_proj;
	hor_ptr_dvs = host_stats->hor_proj;
	ver_ptr_dvs = host_stats->ver_proj;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dis_projections() enter: \
		hproj=%p, vproj=%p, \
		haddr=%x, vaddr=%x\n",
		host_stats->hor_proj, host_stats->ver_proj,
		isp_stats->hor_proj, isp_stats->ver_proj);

#ifndef __KERNEL__
	/* This is the optimized code that uses the aligned_width and
	 * aligned_height for the projections. This should be enabled in the
	 * same patch set that adds the correct handling of these strides to
	 * the DVS engine */
	hor_bytes = hor_num_isp * sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES;
	ver_bytes = ver_num_isp * sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES;

	mmgr_load(hor_ptr_isp, hor_ptr_dvs, hor_bytes);
	mmgr_load(ver_ptr_isp, ver_ptr_dvs, ver_bytes);
#else
	hor_num_dvs = host_stats->grid.height;
	ver_num_dvs = host_stats->grid.width;
	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
		mmgr_load(hor_ptr_isp, hor_ptr_dvs, hor_num_dvs * sizeof(int));
		hor_ptr_isp += hor_num_isp * sizeof(int);
		hor_ptr_dvs += hor_num_dvs;

		mmgr_load(ver_ptr_isp, ver_ptr_dvs, ver_num_dvs * sizeof(int));
		ver_ptr_isp += ver_num_isp * sizeof(int);
		ver_ptr_dvs += ver_num_dvs;
	}
#endif

	sh_css_dtrace(SH_DBG_TRACE,
			"sh_css_get_dis_projections() leave: void\n");
}

static void
ia_css_set_dvs2_coefficients(struct ia_css_isp_parameters *params,
				const struct ia_css_dvs2_coefficients *coefs)
{
	assert(coefs);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs2_coefficients() enter: \
		hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
		hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
		ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
		ver_coefs.even_real=%p, ver_coefs.even_imag=%p", 
		coefs->hor_coefs.odd_real, coefs->hor_coefs.odd_imag,
		coefs->hor_coefs.even_real, coefs->hor_coefs.even_imag,
		coefs->ver_coefs.odd_real, coefs->ver_coefs.odd_imag,
		coefs->ver_coefs.even_real, coefs->ver_coefs.even_imag);
		
	params->dvs2_hor_coefs = coefs->hor_coefs;
	params->dvs2_ver_coefs = coefs->ver_coefs;

	params->dvs2_coef_table_changed = true;
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs2_coefficients() leave: void\n");
}

void
ia_css_get_dvs2_statistics(struct ia_css_dvs2_statistics           *host_stats,
			  const struct ia_css_isp_dvs_statistics *isp_stats)
{
	unsigned int hor_num_isp, ver_num_isp, hor_bytes, ver_bytes;
	hrt_vaddress hor_ptr_isp, ver_ptr_isp;

	assert(host_stats);
	assert(host_stats->hor_prod.odd_real );
	assert(host_stats->hor_prod.odd_imag );
	assert(host_stats->hor_prod.even_real);
	assert(host_stats->hor_prod.even_imag);
	assert(host_stats->ver_prod.odd_real );
	assert(host_stats->ver_prod.odd_imag );
	assert(host_stats->ver_prod.even_real);
	assert(host_stats->ver_prod.even_imag);
	assert(isp_stats);
	assert(isp_stats->hor_proj);
	assert(isp_stats->ver_proj);

	hor_num_isp =
	ver_num_isp = host_stats->grid.aligned_width
		    * host_stats->grid.aligned_height;

	hor_ptr_isp = isp_stats->hor_proj;
	ver_ptr_isp = isp_stats->ver_proj;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dvs2_statistics() enter: \
		hor_coefs.odd_real=%p, hor_coefs.odd_imag=%p\
		hor_coefs.even_real=%p, hor_coefs.even_imag=%p\
		ver_coefs.odd_real=%p, ver_coefs.odd_imag=%p\
		ver_coefs.even_real=%p, ver_coefs.even_imag=%p\
		haddr=%x, vaddr=%x\n",
		host_stats->hor_prod.odd_real, host_stats->hor_prod.odd_imag,
		host_stats->hor_prod.even_real, host_stats->hor_prod.even_imag,
		host_stats->ver_prod.odd_real, host_stats->ver_prod.odd_imag,
		host_stats->ver_prod.even_real, host_stats->ver_prod.even_imag,
		isp_stats->hor_proj, isp_stats->ver_proj);

	hor_bytes = hor_num_isp * sizeof(int);
	ver_bytes = ver_num_isp * sizeof(int);

	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_real, hor_bytes);
	hor_ptr_isp += hor_bytes;
	mmgr_load(hor_ptr_isp, host_stats->hor_prod.odd_imag, hor_bytes);
	hor_ptr_isp += hor_bytes;
	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_real, hor_bytes);
	hor_ptr_isp += hor_bytes;
	mmgr_load(hor_ptr_isp, host_stats->hor_prod.even_imag, hor_bytes);
	
	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_real, ver_bytes);
	ver_ptr_isp += ver_bytes;
	mmgr_load(ver_ptr_isp, host_stats->ver_prod.odd_imag, ver_bytes);
	ver_ptr_isp += ver_bytes;
	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_real, ver_bytes);
	ver_ptr_isp += ver_bytes;
	mmgr_load(ver_ptr_isp, host_stats->ver_prod.even_imag, ver_bytes);

	sh_css_dtrace(SH_DBG_TRACE,
			"sh_css_get_dvs2_statistics() leave: void\n");
}

#if !defined(HAS_NO_HMEM)
static void get_3a_stats_from_hmem(
	struct ia_css_3a_statistics	*host_stats,
	hrt_vaddress				ddr_ptr)
{
	hmem_data_t	*hmem_buf = sh_css_malloc(sizeof_hmem(HMEM0_ID));
	struct ia_css_3a_rgby_output	*out_ptr;
	int			i;

assert(host_stats  != NULL);
assert(host_stats->rgby_data != NULL);
assert(ddr_ptr != mmgr_NULL);
assert(hmem_buf != NULL);

	out_ptr = host_stats->rgby_data;
/*
 * No weighted histogram, hence no grid definition
 */
	mmgr_load(ddr_ptr, (void *)hmem_buf, sizeof_hmem(HMEM0_ID));
/* Deinterleave */
	for (i = 0; i < HMEM_UNIT_SIZE; i++) {
		out_ptr[i].r = hmem_buf[i];
		out_ptr[i].g = hmem_buf[i+HMEM_UNIT_SIZE];
		out_ptr[i].b = hmem_buf[i+HMEM_UNIT_SIZE*2];
		out_ptr[i].y = hmem_buf[i+HMEM_UNIT_SIZE*3];
	}
	sh_css_free(hmem_buf);
return;
}
#endif

static void
get_3a_stats_from_dmem(struct ia_css_3a_statistics *host_stats,
		       hrt_vaddress ddr_ptr)
{
	int ddr_width,
	    out_width,
	    out_height,
	    i;
	struct ia_css_3a_output *out_ptr;

	assert(host_stats);
	assert(host_stats->data);
	assert(ddr_ptr);

	ddr_width  = host_stats->grid.aligned_width;
	out_width  = host_stats->grid.width;
	out_height = host_stats->grid.height;
	out_ptr    = host_stats->data;

	for (i = 0; i < out_height; i++) {
		mmgr_load(ddr_ptr, out_ptr, out_width * sizeof(*out_ptr));
		ddr_ptr += ddr_width * sizeof(*out_ptr);
		out_ptr += out_width;
	}
}

/* MW: this is an ISP function */
STORAGE_CLASS_INLINE int
merge_hi14bit_lo14bit(unsigned short hi, unsigned short lo)
{
	int val = (int) ((((unsigned int) hi << 14) & 0xfffc000) |
			((unsigned int) lo & 0x3fff));
	return val;
}

static void
get_3a_stats_from_vmem(struct ia_css_3a_statistics *host_stats,
		       hrt_vaddress ddr_ptr_hi,
		       hrt_vaddress ddr_ptr_lo)
{
	int out_width,
	    out_height,
	    chunk, rest, kmax, y, x, k, elm_start, elm, ofs, bytes;
	unsigned short *hi, *lo;
	struct ia_css_3a_output *output;
	/* struct size > 128 bytes should not be stored on stack (see checkpatch) */
	static unsigned short s3a_tbl_hi_buf[ISP_S3ATBL_HI_LO_STRIDE *
				     SH_CSS_MAX_BQ_GRID_HEIGHT],
		      s3a_tbl_lo_buf[ISP_S3ATBL_HI_LO_STRIDE *
				     SH_CSS_MAX_BQ_GRID_HEIGHT];

	assert(host_stats!= NULL);
	assert(host_stats->data);
	assert(ddr_ptr_hi != mmgr_NULL);
	assert(ddr_ptr_lo != mmgr_NULL);

	output = host_stats->data;
	out_width  = host_stats->grid.width;
	out_height = host_stats->grid.height;
	hi = s3a_tbl_hi_buf;
	lo = s3a_tbl_lo_buf;

	chunk = (ISP_VEC_NELEMS >> host_stats->grid.deci_factor_log2);
	chunk = max(chunk, 1);
	bytes = ISP_S3ATBL_HI_LO_STRIDE_BYTES * out_height;

	mmgr_load(ddr_ptr_hi, hi, bytes);
	mmgr_load(ddr_ptr_lo, lo, bytes);

	for (y = 0; y < out_height; y++) {
		elm_start = y * ISP_S3ATBL_HI_LO_STRIDE;
		rest = out_width;
		x = 0;
		while (x < out_width) {
			kmax = (rest > chunk) ? chunk : rest;
			ofs = y * out_width + x;
			elm = elm_start + x * sizeof(*output) / sizeof(int);
			for (k = 0; k < kmax; k++, elm++) {
				output[ofs + k].ae_y =
				    merge_hi14bit_lo14bit
				    (hi[elm], lo[elm]);
				output[ofs + k].awb_cnt =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk], lo[elm + chunk]);
				output[ofs + k].awb_gr =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 2],
				     lo[elm + chunk * 2]);
				output[ofs + k].awb_r =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 3],
				     lo[elm + chunk * 3]);
				output[ofs + k].awb_b =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 4],
				     lo[elm + chunk * 4]);
				output[ofs + k].awb_gb =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 5],
				     lo[elm + chunk * 5]);
				output[ofs + k].af_hpf1 =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 6],
				     lo[elm + chunk * 6]);
				output[ofs + k].af_hpf2 =
				    merge_hi14bit_lo14bit
				    (hi[elm + chunk * 7],
				     lo[elm + chunk * 7]);
			}
			x += chunk;
			rest -= chunk;
		}
	}
}

static void
sh_css_process_3a(struct ia_css_isp_parameters *params,
		  unsigned int raw_bit_depth)
{
	unsigned int i;

	/* coefficients to calculate Y */
	params->isp_parameters.ae_y_coef_r =
	    uDIGIT_FITTING(params->s3a_config.ae_y_coef_r, 16, SH_CSS_AE_YCOEF_SHIFT);
	params->isp_parameters.ae_y_coef_g =
	    uDIGIT_FITTING(params->s3a_config.ae_y_coef_g, 16, SH_CSS_AE_YCOEF_SHIFT);
	params->isp_parameters.ae_y_coef_b =
	    uDIGIT_FITTING(params->s3a_config.ae_y_coef_b, 16, SH_CSS_AE_YCOEF_SHIFT);

	/* AWB level gate */
	params->isp_parameters.awb_lg_high_raw =
		uDIGIT_FITTING(params->s3a_config.awb_lg_high_raw, 16, raw_bit_depth);
	params->isp_parameters.awb_lg_low =
		uDIGIT_FITTING(params->s3a_config.awb_lg_low, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.awb_lg_high =
		uDIGIT_FITTING(params->s3a_config.awb_lg_high, 16, SH_CSS_BAYER_BITS);

	/* af fir coefficients */
	for (i = 0; i < 7; ++i) {
		params->isp_parameters.af_fir1[i] =
		  sDIGIT_FITTING(params->s3a_config.af_fir1_coef[i], 15,
				 SH_CSS_AF_FIR_SHIFT);
		params->isp_parameters.af_fir2[i] =
		  sDIGIT_FITTING(params->s3a_config.af_fir2_coef[i], 15,
				 SH_CSS_AF_FIR_SHIFT);
	}
	params->isp_params_changed = true;
	params->s3a_config_changed = false;
}

hrt_vaddress
sh_css_params_ddr_address_map(void)
{
	return sp_ddr_ptrs;
}

/*
 * @GC:
 */
static void
convert_coords_to_ispparams(
	hrt_vaddress ddr_addr,
	const struct ia_css_dvs_6axis_config *config,
	unsigned int i_width,
	unsigned int o_width,
	unsigned int o_height,
	unsigned int uv_flag)
{
	unsigned int i, j;
	gdc_warp_param_mem_t s;
	unsigned int x00, x01, x10, x11,
		     y00, y01, y10, y11;

	unsigned int xmin, ymin;
	unsigned int topleft_x, topleft_y,
		     topleft_x_frac, topleft_y_frac;

	unsigned int blockdim_y = DVS_BLOCKDIM_Y >> uv_flag;
	unsigned int blockdim_x = DVS_BLOCKDIM_X;

	/* number of blocks per height and width */
	unsigned int num_blocks_y = o_height / blockdim_y;
	unsigned int num_blocks_x = o_width / blockdim_x;

	unsigned int in_stride = i_width * DVS_INPUT_BYTES_PER_PIXEL << uv_flag;
	unsigned width;
	unsigned int *xbuff = NULL;
	unsigned int *ybuff = NULL;	                  

assert(config != NULL);
assert(ddr_addr != mmgr_NULL);

	ddr_addr += (2* DVS_6AXIS_COORDS_ELEMS * uv_flag); /* format is Y0 Y1 UV, so UV starts at 3rd position */

assert (o_height % blockdim_y == 0);
assert (o_width % blockdim_x == 0);


	if(uv_flag == 0)
	{
		xbuff = config->xcoords_y;
		ybuff = config->ycoords_y;
		width = config->width_y;
	}
	else
	{
		xbuff = config->xcoords_uv;
		ybuff = config->ycoords_uv;
		width = config->width_uv;
	}
	
	sh_css_dtrace(SH_DBG_TRACE, "convert_coords_to_ispparams blockdim_x %d blockdim_y %d\n",blockdim_x,blockdim_y);
	sh_css_dtrace(SH_DBG_TRACE, "convert_coords_to_ispparams num_blocks_x %d num_blocks_y %d\n",num_blocks_x,num_blocks_y);
	
	for (j = 0; j < num_blocks_y; j++) {
		for (i = 0; i < num_blocks_x; i++) {	

		      x00 = xbuff[j * width + i];
		      x01 = xbuff[j * width + (i+1)];
		      x10 = xbuff[(j+1) * width + i];
		      x11 = xbuff[(j+1) * width + (i+1)];
		
		      y00 = ybuff[j * width + i];
		      y01 = ybuff[j * width + (i+1)];
		      y10 = ybuff[(j+1) * width + i];
		      y11 = ybuff[(j+1) * width + (i+1)];

			/* TODO: Assert that right column's X is greater */
			xmin = min(x00, x10);
			/* TODO: Assert that bottom row's Y is greater */
			ymin = min(y00, y01);

#if 0
			/* TODO: Round width to the multiple of bus width */
			xmax = max(x01, x11);
			ymax = max(y10, y11);
			in_block_width  = xmax - xmin;
			in_block_height = ymax - ymin;
#else
			/*
			 * For initial testing, we are using constant input
			 * block size
			 * */
			s.in_block_width  = 128;
			s.in_block_height = 96 >> uv_flag;
#endif

			topleft_y = ymin >> DVS_COORD_FRAC_BITS;
			topleft_x = ((xmin >> DVS_COORD_FRAC_BITS)
					>> XMEM_ALIGN_LOG2)
					<< (XMEM_ALIGN_LOG2);

			s.in_addr_offset = topleft_y * in_stride + topleft_x;

			topleft_x_frac = topleft_x << (DVS_COORD_FRAC_BITS);
			topleft_y_frac = topleft_y << (DVS_COORD_FRAC_BITS);

			s.p0_x = x00 - topleft_x_frac;
			s.p1_x = x01 - topleft_x_frac;
			s.p2_x = x10 - topleft_x_frac;
			s.p3_x = x11 - topleft_x_frac;

			s.p0_y = y00 - topleft_y_frac;
			s.p1_y = y01 - topleft_y_frac;
			s.p2_y = y10 - topleft_y_frac;
			s.p3_y = y11 - topleft_y_frac;
#if 0
			sh_css_dtrace(SH_DBG_TRACE, "j: %d\ti:%d\n", j, i);
			sh_css_dtrace(SH_DBG_TRACE, "offset: %d\n", s.in_addr_offset);
			sh_css_dtrace(SH_DBG_TRACE, "relative_x[0]: %d\n", s.relative_x[0]);
			sh_css_dtrace(SH_DBG_TRACE, "relative_x[1]: %d\n", s.relative_x[1]);
			sh_css_dtrace(SH_DBG_TRACE, "relative_x[2]: %d\n", s.relative_x[2]);
			sh_css_dtrace(SH_DBG_TRACE, "relative_x[3]: %d\n", s.relative_x[3]);
			sh_css_dtrace(SH_DBG_TRACE, "relative_y[0]: %d\n", s.relative_y[0]);
			sh_css_dtrace(SH_DBG_TRACE, "relative_y[1]: %d\n", s.relative_y[1]);
			sh_css_dtrace(SH_DBG_TRACE, "relative_y[2]: %d\n", s.relative_y[2]);
			sh_css_dtrace(SH_DBG_TRACE, "relative_y[3]: %d\n", s.relative_y[3]);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_x_nofrac[0]: %d\n", s.relative_x[0]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_x_nofrac[1]: %d\n", s.relative_x[1]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_x_nofrac[2]: %d\n", s.relative_x[2]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_x_nofrac[3]: %d\n", s.relative_x[3]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_y_nofrac[0]: %d\n", s.relative_y[0]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_y_nofrac[1]: %d\n", s.relative_y[1]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_y_nofrac[2]: %d\n", s.relative_y[2]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE,
					"relative_y_nofrac[3]: %d\n", s.relative_y[3]>>DVS_COORD_FRAC_BITS);
			sh_css_dtrace(SH_DBG_TRACE, "\n");
#endif

			/* HMM STORE the struct "s" */
			mmgr_store(ddr_addr,
				   (void *)(&s),
				   sizeof(gdc_warp_param_mem_t));

			// storage format:
			// Y0 Y1 UV0 Y2 Y3 UV1
			if (uv_flag) {
				ddr_addr += DVS_6AXIS_COORDS_ELEMS * 3;
		}
			else {
        ddr_addr += DVS_6AXIS_COORDS_ELEMS * (1 + (i&1)); // increment with 2 incase x is odd, this to skip the uv position.
	}
			
}
	}
}

static void
store_dvs_6axis_config(
	struct ia_css_isp_parameters *params,
	const struct sh_css_binary *binary,
	hrt_vaddress ddr_addr_y)
{
	unsigned int i_width  = binary->in_frame_info.res.width;
	unsigned int o_width  = binary->out_frame_info.res.width;
	unsigned int o_height = binary->out_frame_info.res.height;
	
	assert(binary != NULL);
	assert(ddr_addr_y != mmgr_NULL);
	assert(params->dvs_6axis_config != NULL);
	
	/* Y plane */
	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
				    i_width, o_width, o_height, 0);
	/* UV plane (packed inside the y plane) */
	convert_coords_to_ispparams(ddr_addr_y, params->dvs_6axis_config,
				    i_width/2, o_width/2, o_height/2, 1);
				    

	params->isp_params_changed = true;	
}
/* ****************************************************
 * Each coefficient is stored as 7bits to fit 2 of them into one
 * ISP vector element, so we will store 4 coefficents on every
 * memory word (32bits)
 *
 * 0: Coefficient 0 used bits
 * 1: Coefficient 1 used bits
 * 2: Coefficient 2 used bits
 * 3: Coefficient 3 used bit3
 * x: not used
 *
 * xx33333332222222 | xx11111110000000
 *
 * ***************************************************
 */
static void
store_fpntbl(struct ia_css_isp_parameters *params, hrt_vaddress ptr)
{
	unsigned int i, j;
	short *data_ptr = params->fpn_table.data;

assert(ptr != mmgr_NULL);

	for (i = 0; i < params->fpn_table.height; i++) {
		for (j = 0;
		     j < params->fpn_table.width;
		     j += 4, ptr += 4, data_ptr += 4) {
			int data = data_ptr[0] << 0 |
				   data_ptr[1] << 7 |
				   data_ptr[2] << 16 |
				   data_ptr[3] << 23;
			mmgr_store(ptr, (void *)(&data), sizeof(data));
		}
	}
}

static void
convert_raw_to_fpn(struct ia_css_isp_parameters *params)
{
	short maxval = 0;
	unsigned int i;

	/* Find the maximum value in the table */
	for (i = 0; i < params->fpn_table.height * params->fpn_table.width; i++) {
		short val = params->fpn_table.data[i];
		/* Make sure FPN value can be represented in 13-bit unsigned
		 * number (ISP precision - 1), but note that actual input range
		 * depends on precision of input frame data.
		 */
		if (val < 0) {
/* Checkpatch patch */
			val = 0;
		} else if (val >= (1 << 13)) {
/* Checkpatch patch */
/* MW: BUG, is "13" a system or application property */
			val = (1 << 13) - 1;
		}
		maxval = max(maxval, val);
	}
	/* Find the lowest shift value to remap the values in the range
	 * 0..maxval to 0..2^shiftval*63.
	 */
	params->fpn_table.shift = 0;
	while (maxval > 63) {
/* MW: BUG, is "63" a system or application property */
		maxval /= 2;
		params->fpn_table.shift++;
	}
	/* Adjust the values in the table for the shift value */
	for (i = 0; i < params->fpn_table.height * params->fpn_table.width; i++)
		((unsigned short *) params->fpn_table.data)[i] >>= params->fpn_table.shift;
}

enum ia_css_err
sh_css_set_black_frame(struct ia_css_stream *stream,
	const struct ia_css_frame *raw_black_frame)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	/* this function desperately needs to be moved to the ISP or SP such
	 * that it can use the DMA.
	 */
	unsigned int height = raw_black_frame->info.res.height,
		     width = raw_black_frame->info.padded_width,
		     y, x, k, data;
	hrt_vaddress ptr = raw_black_frame->data
		+ raw_black_frame->planes.raw.offset;

assert(raw_black_frame != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_black_frame() enter: \
		black_frame=%p\n",raw_black_frame);

	if (params->fpn_table.data &&
	    (params->fpn_table.width != width || params->fpn_table.height != height)) {
		sh_css_free(params->fpn_table.data);
		params->fpn_table.data = NULL;
	}
	if (params->fpn_table.data == NULL) {
		params->fpn_table.data = sh_css_malloc(height * width * sizeof(short));
		if (!params->fpn_table.data) {
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_black_frame() leave: \
		return_err=%d\n",IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY);
			return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
		}
		params->fpn_table.width = width;
		params->fpn_table.height = height;
		params->fpn_table.shift = 0;
	}

	/* store raw to fpntbl */
	for (y = 0; y < height; y++) {
		for (x = 0; x < width; x += (ISP_VEC_NELEMS * 2)) {
			int ofs = y * width + x;
			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
				mmgr_load(ptr, (void *)(&data), sizeof(int));
				params->fpn_table.data[ofs + 2 * k] =
				    (short) (data & 0xFFFF);
				params->fpn_table.data[ofs + 2 * k + 2] =
				    (short) ((data >> 16) & 0xFFFF);
	ptr += sizeof(int);	/* byte system address */
			}
			for (k = 0; k < ISP_VEC_NELEMS; k += 2) {
				mmgr_load(ptr, (void *)(&data), sizeof(int));
				params->fpn_table.data[ofs + 2 * k + 1] =
				    (short) (data & 0xFFFF);
				params->fpn_table.data[ofs + 2 * k + 3] =
				    (short) ((data >> 16) & 0xFFFF);
	ptr += sizeof(int);	/* byte system address */
			}
		}
	}

	/* raw -> fpn */
	convert_raw_to_fpn(params);

	/* overwrite isp parameter */
	params->isp_parameters.fpn_shift = params->fpn_table.shift;
	params->isp_parameters.fpn_enabled = 1;
	params->fpn_table_changed = true;
	params->isp_params_changed = true;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_black_frame() leave: \
		return_err=%d\n",IA_CSS_SUCCESS);

	return IA_CSS_SUCCESS;
}

struct ia_css_shading_table *ia_css_shading_table_alloc(
	unsigned int width,
	unsigned int height)
{
	unsigned int i;
	struct ia_css_shading_table *me = sh_css_malloc(sizeof(*me));

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_alloc() enter:\n");

	if (me == NULL) {
/* Checkpatch patch */
		return me;
	}
	me->width		 = width;
	me->height		= height;
	me->sensor_width  = 0;
	me->sensor_height = 0;
	me->fraction_bits = 0;
	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
		me->data[i] =
		    sh_css_malloc(width * height * sizeof(*me->data[0]));
		if (me->data[i] == NULL) {
			unsigned int j;
			for (j = 0; j < i; j++)
				sh_css_free(me->data[j]);
			sh_css_free(me);
			return NULL;
		}
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_alloc() leave:\n");

	return me;
}

void
ia_css_shading_table_free(struct ia_css_shading_table *table)
{
	unsigned int i;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_free() enter:\n");

	if (table == NULL) {
		sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_free() leave:\n");
		return;
	}

	for (i = 0; i < IA_CSS_SC_NUM_COLORS; i++) {
		if (table->data[i])
			sh_css_free(table->data[i]);
	}
	sh_css_free(table);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_shading_table_free() leave:\n");
}

bool
sh_css_params_set_binning_factor(struct ia_css_stream *stream, unsigned int binning_fact)
{	
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_set_binning_factor() enter:\n");

	if (params->sensor_binning != binning_fact) {
		params->sensor_binning = binning_fact;
		params->sc_table_changed = true;
	}
	
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_set_binning_factor() leave:\n");

	return params->sc_table_changed;
}

static void
sh_css_set_shading_table(struct ia_css_stream *stream,
			 const struct ia_css_shading_table *table)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_shading_table() enter:\n");
	if (!table->enable)
		table = NULL;

	if (table != params->sc_table) {
		params->sc_table = table;
		params->sc_table_changed = true;
		/* Not very clean, this goes to sh_css.c to invalidate the
		 * shading table for all pipes. Should replaced by a loop
		 * and a pipe-specific call.
		 */
		sh_css_invalidate_shading_tables(stream);
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_set_shading_table() leave:\n");
}

static void
store_sctbl(
	    struct ia_css_isp_parameters *params,
	    const struct sh_css_binary *binary,
	    hrt_vaddress ddr_addr,
	    const struct ia_css_shading_table *shading_table)
{
	unsigned int i, j, aligned_width, row_padding;

assert(binary != NULL);
assert(ddr_addr != mmgr_NULL);
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_sctbl() enter:\n");

	if (shading_table == NULL) {
/* Checkpatch patch */
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_sctbl() leave:\n");
		return;
	}

	aligned_width = binary->sctbl_aligned_width_per_color;
	params->isp_parameters.sc_gain_shift = shading_table->fraction_bits;
	row_padding = aligned_width - shading_table->width;

	for (i = 0; i < shading_table->height; i++) {
		for (j = 0; j < IA_CSS_SC_NUM_COLORS; j++) {
			mmgr_store(ddr_addr,
				   &shading_table->data[j]
					[i*shading_table->width],
				   shading_table->width * sizeof(short));
			ddr_addr += shading_table->width * sizeof(short);
			mmgr_clear(ddr_addr,
				   row_padding * sizeof(short));
			ddr_addr += row_padding * sizeof(short);
		}
	}
	params->isp_params_changed = true;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_sctbl() leave:\n");
}

static void
sh_css_process_wb(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_wb() enter:\n");

	params->isp_parameters.wb_gain_shift =
	    uISP_REG_BIT - params->wb_config.integer_bits;
	params->isp_parameters.wb_gain_gr =
	    uDIGIT_FITTING(params->wb_config.gr, 16 - params->wb_config.integer_bits,
			   params->isp_parameters.wb_gain_shift);
	params->isp_parameters.wb_gain_r =
	    uDIGIT_FITTING(params->wb_config.r, 16 - params->wb_config.integer_bits,
			   params->isp_parameters.wb_gain_shift);
	params->isp_parameters.wb_gain_b =
	    uDIGIT_FITTING(params->wb_config.b, 16 - params->wb_config.integer_bits,
			   params->isp_parameters.wb_gain_shift);
	params->isp_parameters.wb_gain_gb =
	    uDIGIT_FITTING(params->wb_config.gb, 16 - params->wb_config.integer_bits,
			   params->isp_parameters.wb_gain_shift);
	params->isp_params_changed = true;
	params->wb_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_wb() leave:\n");
}

static void
sh_css_process_cc(struct ia_css_isp_parameters *params)
{
	int	i;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cc() enter:\n");

	for (i=0;i<N_CSC_KERNEL_PARAM_SET;i++) {
		if (params->cc_config_changed[i]) {
			params->isp_parameters.csc_kernel_param[i].m_shift    = (int) params->cc_config[i].fraction_bits;
			params->isp_parameters.csc_kernel_param[i].m00 = (int) params->cc_config[i].matrix[0];
			params->isp_parameters.csc_kernel_param[i].m01 = (int) params->cc_config[i].matrix[1];
			params->isp_parameters.csc_kernel_param[i].m02 = (int) params->cc_config[i].matrix[2];
			params->isp_parameters.csc_kernel_param[i].m10 = (int) params->cc_config[i].matrix[3];
			params->isp_parameters.csc_kernel_param[i].m11 = (int) params->cc_config[i].matrix[4];
			params->isp_parameters.csc_kernel_param[i].m12 = (int) params->cc_config[i].matrix[5];
			params->isp_parameters.csc_kernel_param[i].m20 = (int) params->cc_config[i].matrix[6];
			params->isp_parameters.csc_kernel_param[i].m21 = (int) params->cc_config[i].matrix[7];
			params->isp_parameters.csc_kernel_param[i].m22 = (int) params->cc_config[i].matrix[8];
			params->isp_params_changed = true;
			params->cc_config_changed[i] = false;
		}
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cc() leave:\n");
}

static void
sh_css_process_tnr(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_tnr() enter:\n");

	params->isp_parameters.tnr_coef =
	    uDIGIT_FITTING(params->tnr_config.gain, 16, SH_CSS_TNR_COEF_SHIFT);
	params->isp_parameters.tnr_threshold_Y =
	    uDIGIT_FITTING(params->tnr_config.threshold_y, 16, SH_CSS_ISP_YUV_BITS);
	params->isp_parameters.tnr_threshold_C =
	    uDIGIT_FITTING(params->tnr_config.threshold_uv, 16, SH_CSS_ISP_YUV_BITS);
	params->isp_params_changed = true;
	params->tnr_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_tnr() leqave:\n");
}

static void
sh_css_process_ob(struct ia_css_isp_parameters *params,
		  unsigned int raw_bit_depth)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ob() enter:\n");

	switch (params->ob_config.mode) {
	case IA_CSS_OB_MODE_FIXED:
		params->isp_parameters.ob_blacklevel_gr
			= params->ob_config.level_gr >> (16 - raw_bit_depth);
		params->isp_parameters.ob_blacklevel_r
			= params->ob_config.level_r  >> (16 - raw_bit_depth);
		params->isp_parameters.ob_blacklevel_b
			= params->ob_config.level_b  >> (16 - raw_bit_depth);
		params->isp_parameters.ob_blacklevel_gb
			= params->ob_config.level_gb >> (16 - raw_bit_depth);
		params->isp_parameters.obarea_start_bq = 0;
		params->isp_parameters.obarea_length_bq = 0;
		params->isp_parameters.obarea_length_bq_inverse = 0;
		break;
	case IA_CSS_OB_MODE_RASTER:
		params->isp_parameters.ob_blacklevel_gr = 0;
		params->isp_parameters.ob_blacklevel_r = 0;
		params->isp_parameters.ob_blacklevel_b = 0;
		params->isp_parameters.ob_blacklevel_gb = 0;
		params->isp_parameters.obarea_start_bq =
		    params->ob_config.start_position;
		params->isp_parameters.obarea_length_bq =
		    ((params->ob_config.end_position - params->ob_config.start_position) + 1);
		params->isp_parameters.obarea_length_bq_inverse =
		    (1 << 12) / params->isp_parameters.obarea_length_bq;
		break;
	default:
		params->isp_parameters.ob_blacklevel_gr = 0;
		params->isp_parameters.ob_blacklevel_r = 0;
		params->isp_parameters.ob_blacklevel_b = 0;
		params->isp_parameters.ob_blacklevel_gb = 0;
		params->isp_parameters.obarea_start_bq = 0;
		params->isp_parameters.obarea_length_bq = 0;
		params->isp_parameters.obarea_length_bq_inverse = 0;
		break;
	}
	params->isp_params_changed = true;
	params->ob_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ob() leaev:\n");
}

static void
sh_css_process_dp(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_dp() enter:\n");

	params->isp_parameters.dp_threshold_single_when_2adjacent_on =
	    SH_CSS_BAYER_MAXVAL;
	params->isp_parameters.dp_threshold_2adjacent_when_2adjacent_on =
	    uDIGIT_FITTING(params->dp_config.threshold, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.dp_threshold_single_when_2adjacent_off =
	    uDIGIT_FITTING(params->dp_config.threshold, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.dp_threshold_2adjacent_when_2adjacent_off =
	    SH_CSS_BAYER_MAXVAL;
	params->isp_parameters.dp_gain =
	    uDIGIT_FITTING(params->dp_config.gain, 8, SH_CSS_DP_GAIN_SHIFT);

#if SH_CSS_ISP_SUPPORT_DPC_BEFORE_WB
	{
		int gain = params->dp_config.gain;
		int gr   = params->wb_config.gr;
		int r    = params->wb_config.r;
		int b    = params->wb_config.b;
		int gb   = params->wb_config.gb;

		params->isp_parameters.dpc_coef_rr_gr =
		  uDIGIT_FITTING (gain * gr / r, 8, SH_CSS_DP_GAIN_SHIFT);
		params->isp_parameters.dpc_coef_rr_gb =
		  uDIGIT_FITTING (gain * gb / r, 8, SH_CSS_DP_GAIN_SHIFT);
		params->isp_parameters.dpc_coef_bb_gb =
		  uDIGIT_FITTING (gain * gb / b, 8, SH_CSS_DP_GAIN_SHIFT);
		params->isp_parameters.dpc_coef_bb_gr =
		  uDIGIT_FITTING (gain * gr / b, 8, SH_CSS_DP_GAIN_SHIFT);
		params->isp_parameters.dpc_coef_gr_rr =
		  uDIGIT_FITTING (gain * r / gr, 8, SH_CSS_DP_GAIN_SHIFT);
		params->isp_parameters.dpc_coef_gr_bb =
		  uDIGIT_FITTING (gain * b / gr, 8, SH_CSS_DP_GAIN_SHIFT);
		params->isp_parameters.dpc_coef_gb_bb =
		  uDIGIT_FITTING (gain * b / gb, 8, SH_CSS_DP_GAIN_SHIFT);
		params->isp_parameters.dpc_coef_gb_rr =
		  uDIGIT_FITTING (gain * r / gb, 8, SH_CSS_DP_GAIN_SHIFT);
	}
#endif
	params->isp_params_changed = true;
	params->dp_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_dp() leave:\n");
}

static void
sh_css_process_nr_ee(struct ia_css_isp_parameters *params)
{
	int asiWk1, asiWk2, asiWk3;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_nr_ee() enter:\n");

	/* BNR (Bayer Noise Reduction) */
	params->isp_parameters.bnr_threshold_low =
	    uDIGIT_FITTING(params->nr_config.direction, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.bnr_threshold_width_log2 = uFRACTION_BITS_FITTING(8);
	params->isp_parameters.bnr_threshold_width =
	    1 << params->isp_parameters.bnr_threshold_width_log2;
	params->isp_parameters.bnr_gain_all =
	    uDIGIT_FITTING(params->nr_config.bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
	params->isp_parameters.bnr_gain_dir =
	    uDIGIT_FITTING(params->nr_config.bnr_gain, 16, SH_CSS_BNR_GAIN_SHIFT);
	params->isp_parameters.bnr_clip = uDIGIT_FITTING(
					(unsigned)16384, 16, SH_CSS_BAYER_BITS);

	/* YNR (Y Noise Reduction), YEE (Y Edge Enhancement) */
	asiWk1 = (int) params->ee_config.gain;
	asiWk2 = asiWk1 / 8;
	asiWk3 = asiWk1 / 4;
	params->isp_parameters.ynr_threshold =
		uDIGIT_FITTING((unsigned)8192, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.ynr_gain_all =
	    uDIGIT_FITTING(params->nr_config.ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
	params->isp_parameters.ynr_gain_dir =
	    uDIGIT_FITTING(params->nr_config.ynr_gain, 16, SH_CSS_YNR_GAIN_SHIFT);
	params->isp_parameters.ynryee_dirthreshold_s =
	    min((uDIGIT_FITTING(params->nr_config.direction, 16, SH_CSS_BAYER_BITS)
				    << 1),
		SH_CSS_BAYER_MAXVAL);
	params->isp_parameters.ynryee_dirthreshold_g =
	    min((uDIGIT_FITTING(params->nr_config.direction, 16, SH_CSS_BAYER_BITS)
				    << 4),
		SH_CSS_BAYER_MAXVAL);
	params->isp_parameters.ynryee_dirthreshold_width_log2 =
	    uFRACTION_BITS_FITTING(8);
	params->isp_parameters.ynryee_dirthreshold_width =
	    1 << params->isp_parameters.ynryee_dirthreshold_width_log2;
	params->isp_parameters.yee_detailgain =
	    uDIGIT_FITTING(params->ee_config.detail_gain, 11,
			   SH_CSS_YEE_DETAIL_GAIN_SHIFT);
	params->isp_parameters.yee_coring_s =
	    (uDIGIT_FITTING((unsigned)56, 16, SH_CSS_BAYER_BITS) *
	     params->ee_config.threshold) >> 8;
	params->isp_parameters.yee_coring_g =
	    (uDIGIT_FITTING((unsigned)224, 16, SH_CSS_BAYER_BITS) *
	     params->ee_config.threshold) >> 8;
	/* 8; // *1.125 ->[s4.8] */
	params->isp_parameters.yee_scale_plus_s =
	    (asiWk1 + asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
	/* 8; // ( * -.25)->[s4.8] */
	params->isp_parameters.yee_scale_plus_g =
	    (0 - asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
	/* 8; // *0.875 ->[s4.8] */
	params->isp_parameters.yee_scale_minus_s =
	    (asiWk1 - asiWk2) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
	/* 8; // ( *.25 ) ->[s4.8] */
	params->isp_parameters.yee_scale_minus_g =
	    (asiWk3) >> (11 - SH_CSS_YEE_SCALE_SHIFT);
	params->isp_parameters.yee_clip_plus_s =
	    uDIGIT_FITTING((unsigned)32760, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.yee_clip_plus_g = 0;
	params->isp_parameters.yee_clip_minus_s =
	    uDIGIT_FITTING((unsigned)504, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.yee_clip_minus_g =
	    uDIGIT_FITTING((unsigned)32256, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.ynryee_Yclip = SH_CSS_BAYER_MAXVAL;
	params->isp_params_changed = true;
	params->nr_config_changed = false;
	params->ee_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_nr_ee() leave:\n");
}

static void
sh_css_process_de(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_de() enter:\n");

	params->isp_parameters.de_pixelnoise =
	    uDIGIT_FITTING(params->de_config.pixelnoise, 16, SH_CSS_BAYER_BITS);
	params->isp_parameters.de_c1_coring_threshold =
	    uDIGIT_FITTING(params->de_config.c1_coring_threshold, 16,
			   SH_CSS_BAYER_BITS);
	params->isp_parameters.de_c2_coring_threshold =
	    uDIGIT_FITTING(params->de_config.c2_coring_threshold, 16,
			   SH_CSS_BAYER_BITS);
	params->isp_params_changed = true;
	params->de_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_de() leave:\n");
}

static void
sh_css_process_gc(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_gc() enter:\n");

	params->isp_parameters.gamma_gain_k1 =
	    uDIGIT_FITTING((int)params->gc_config.gain_k1, 16,
		IA_CSS_GAMMA_GAIN_K_SHIFT);
	params->isp_parameters.gamma_gain_k2 =
	    uDIGIT_FITTING((int)params->gc_config.gain_k2, 16,
		IA_CSS_GAMMA_GAIN_K_SHIFT);
	params->isp_params_changed = true;
	params->gc_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_gc() leave:\n");
}

static void
sh_css_process_anr(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_anr() enter:\n");

	params->isp_parameters.anr_threshold = params->anr_config.threshold;
	params->isp_params_changed = true;
	params->anr_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_anr() leave:\n");
}

static void
sh_css_process_ce(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ce() enter:\n");

	params->isp_parameters.ce_uv_level_min = params->ce_config.uv_level_min;
	params->isp_parameters.ce_uv_level_max = params->ce_config.uv_level_max;
	params->isp_params_changed = true;
	params->ce_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ce() leave:\n");
}

static void sh_css_process_zoom_and_motion(
	struct ia_css_isp_parameters *params,
	enum ia_css_pipe_id pipe_id,
	const struct sh_css_pipeline_stage *first_stage)
{
/* first_stage can be  NULL */
	const struct sh_css_pipeline_stage *stage;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_zoom_and_motion() enter:\n");

	/* Go through all stages to udate uds and cropping */
	for (stage = first_stage; stage; stage = stage->next) {

		struct sh_css_binary *binary;
		struct sh_css_binary tmp_binary;

		const struct ia_css_binary_info *info = NULL;

		binary = stage->binary;
		if (binary) {
			info = binary->info;
		} else {
			const struct sh_css_binary_args *args = &stage->args;
			info = &stage->firmware->info.isp;
			sh_css_fill_binary_info(info, false, false,
				IA_CSS_STREAM_FORMAT_RAW_10,
				args->in_frame  ? &args->in_frame->info  : NULL,
				args->out_frame ? &args->out_frame->info : NULL,
				args->out_vf_frame ? &args->out_vf_frame->info
									: NULL,
				&tmp_binary,
				false,
				NULL);
			binary = &tmp_binary;
			binary->info = info;
		}

		assert(stage->stage_num < SH_CSS_MAX_STAGES);
		sh_css_update_uds_and_crop_info(
			info,
			&binary->in_frame_info,
			&binary->out_frame_info,
			&binary->dvs_envelope,
			pipe_id == IA_CSS_PIPE_ID_PREVIEW,
			&(params->dz_config),
			&(params->motion_config),
			&(params->isp_parameters.uds[stage->stage_num]),
			&(params->isp_parameters.sp_out_crop_pos[stage->stage_num]));
	}
	params->isp_params_changed = true;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_zoom_and_motion() leave:\n");
}

static void
sh_css_process_ecd(struct ia_css_isp_parameters *params)
{
	(void) params;
#if SH_CSS_ISP_PARAMS_VERSION == 2
	params->isp_parameters.ecd_zip_strength = params->ecd_config.zip_strength;
	params->isp_parameters.ecd_fc_strength  = params->ecd_config.fc_strength;
	params->isp_parameters.ecd_fc_debias    = params->ecd_config.fc_debias;
#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */
}

static void
sh_css_process_ynr(struct ia_css_isp_parameters *params)
{
	(void) params;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ynr() enter:\n");

#if SH_CSS_ISP_PARAMS_VERSION == 2
	params->isp_parameters.yee_edge_sense_gain_0   = params->ynr_config.edge_sense_gain_0;
	params->isp_parameters.yee_edge_sense_gain_1   = params->ynr_config.edge_sense_gain_1;
	params->isp_parameters.yee_corner_sense_gain_0 = params->ynr_config.corner_sense_gain_0;
	params->isp_parameters.yee_corner_sense_gain_1 = params->ynr_config.corner_sense_gain_1;
#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ynr() leave:\n");
}

static void
sh_css_process_fc(struct ia_css_isp_parameters *params)
{
	(void) params;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_fc() enter:\n");

#if SH_CSS_ISP_PARAMS_VERSION == 2
	params->isp_parameters.fc_gain_exp   = params->fc_config.gain_exp;

	params->isp_parameters.fc_gain_pos_0 = params->fc_config.gain_pos_0;
	params->isp_parameters.fc_gain_pos_1 = params->fc_config.gain_pos_1;
	params->isp_parameters.fc_gain_neg_0 = params->fc_config.gain_neg_0;
	params->isp_parameters.fc_gain_neg_1 = params->fc_config.gain_neg_1;

	params->isp_parameters.fc_crop_pos_0 = params->fc_config.crop_pos_0;
	params->isp_parameters.fc_crop_pos_1 = params->fc_config.crop_pos_1;
	params->isp_parameters.fc_crop_neg_0 = params->fc_config.crop_neg_0;
	params->isp_parameters.fc_crop_neg_1 = params->fc_config.crop_neg_1;
#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_fc() leave:\n");
}

static void
sh_css_process_cnr(struct ia_css_isp_parameters *params)
{
	(void) params;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cnr() enter:\n");

#if SH_CSS_ISP_PARAMS_VERSION == 2
	params->isp_parameters.cnr_coring_u = params->cnr_config.coring_u;
	params->isp_parameters.cnr_coring_v = params->cnr_config.coring_v;
	params->isp_parameters.cnr_sense_gain_vy = params->cnr_config.sense_gain_vy;
	params->isp_parameters.cnr_sense_gain_vu = params->cnr_config.sense_gain_vu;
	params->isp_parameters.cnr_sense_gain_vv = params->cnr_config.sense_gain_vv;
	params->isp_parameters.cnr_sense_gain_hy = params->cnr_config.sense_gain_hy;
	params->isp_parameters.cnr_sense_gain_hu = params->cnr_config.sense_gain_hu;
	params->isp_parameters.cnr_sense_gain_hv = params->cnr_config.sense_gain_hv;
#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_cnr() leave:\n");
}

static void
sh_css_process_macc(struct ia_css_isp_parameters *params)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_macc() enter:\n");

	params->isp_parameters.exp = params->macc_config.exp;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_macc() leave:\n");
}

#if SH_CSS_ISP_PARAMS_VERSION == 2
static void ctc_gradient(
	int *dydx, int *shift,
	int y1, int y0, int x1, int x0)
{
	int frc_bits = max(IA_CSS_CTC_COEF_SHIFT, 16);
	int dy = y1 - y0;
	int dx = x1 - x0;
	int dydx_int = dy / dx;
	int dydx_frc = ((dy - dydx_int * dx) << frc_bits) / dx;
	int sft;

	/* max_dydx = the maxinum gradient = the maximum y (gain) */
	int max_dydx = (1 << IA_CSS_CTC_COEF_SHIFT) - 1;

	assert(y0 >= 0 && y0 <= max_dydx);
	assert(y1 >= 0 && y1 <= max_dydx);
	assert(x0 < x1);
	assert(dydx != NULL);
	assert(shift != NULL);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ctc_gradient() enter:\n");
	
	/* search "sft" which meets this condition:
		   (1 << (IA_CSS_CTC_COEF_SHIFT - 1))
		<= (((float)dy / (float)dx) * (1 << sft))
		<= ((1 << IA_CSS_CTC_COEF_SHIFT) - 1) */
	for (sft = 0; sft <= IA_CSS_CTC_COEF_SHIFT; sft++) {
		int tmp_dydx = (dydx_int << sft)
			     + (dydx_frc >> (frc_bits - sft));
		if (tmp_dydx <= max_dydx) {
			*dydx = tmp_dydx;
			*shift = sft;
		}
		if (tmp_dydx >= max_dydx)
			break;		
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ctc_gradient() leave:\n");
}
#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */

static void
sh_css_process_ctc(struct ia_css_isp_parameters *params)
{
	(void) params;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ctc() enter:\n");

#if SH_CSS_ISP_PARAMS_VERSION == 2
	params->isp_parameters.ctc_y0 = params->ctc_config.y0;
	params->isp_parameters.ctc_y1 = params->ctc_config.y1;
	params->isp_parameters.ctc_y2 = params->ctc_config.y2;
	params->isp_parameters.ctc_y3 = params->ctc_config.y3;
	params->isp_parameters.ctc_y4 = params->ctc_config.y4;
	params->isp_parameters.ctc_y5 = params->ctc_config.y5;

	params->isp_parameters.ctc_ce_gain_exp = params->ctc_config.ce_gain_exp;

	params->isp_parameters.ctc_x1 = params->ctc_config.x1;
	params->isp_parameters.ctc_x2 = params->ctc_config.x2;
	params->isp_parameters.ctc_x3 = params->ctc_config.x3;
	params->isp_parameters.ctc_x4 = params->ctc_config.x4;

	ctc_gradient(&(params->isp_parameters.ctc_dydx0),
		     &(params->isp_parameters.ctc_dydx0_shift),
		     params->ctc_config.y1, params->ctc_config.y0,
		     params->ctc_config.x1, 0);

	ctc_gradient(&(params->isp_parameters.ctc_dydx1),
		     &(params->isp_parameters.ctc_dydx1_shift),
		     params->ctc_config.y2, params->ctc_config.y1,
		     params->ctc_config.x2, params->ctc_config.x1);

	ctc_gradient(&params->isp_parameters.ctc_dydx2,
		     &params->isp_parameters.ctc_dydx2_shift,
		     params->ctc_config.y3, params->ctc_config.y2,
		     params->ctc_config.x3, params->ctc_config.x2);

	ctc_gradient(&params->isp_parameters.ctc_dydx3,
		     &params->isp_parameters.ctc_dydx3_shift,
		     params->ctc_config.y4, params->ctc_config.y3,
		     params->ctc_config.x4, params->ctc_config.x3);

	ctc_gradient(&(params->isp_parameters.ctc_dydx4),
		     &(params->isp_parameters.ctc_dydx4_shift),
		     params->ctc_config.y5, params->ctc_config.y4,
		     SH_CSS_BAYER_MAXVAL, params->ctc_config.x4);
#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_ctc() leave:\n");
}

static void
sh_css_process_aa(struct ia_css_isp_parameters *params)
{
	(void) params;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_aa() enter:\n");

#if SH_CSS_ISP_PARAMS_VERSION == 2
	params->isp_parameters.aa_scale = params->aa_config.scale;
#endif /* SH_CSS_ISP_PARAMS_VERSION == 2 */

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_process_aa() leave:\n");
}

static void
sh_css_set_gamma_table(struct ia_css_isp_parameters *params,
			const struct ia_css_gamma_table *table)
{
	assert(table);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gamma_table() enter: "
		"table=%p\n",table);

	params->gamma_table = *table;
	params->gamma_table_changed = true;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gamma_table() leave: "
		"return_void\n");
}

static void
sh_css_get_gamma_table(const struct ia_css_isp_parameters *params,
			struct ia_css_gamma_table *table)
{
	assert(table != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gamma_table() enter: "
		"table=%p\n",table);

	*table = params->gamma_table;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gamma_table() leave: "
		"*table=%p\n",*table);
}

static void
sh_css_set_ctc_table(struct ia_css_isp_parameters *params,
			const struct ia_css_ctc_table *table)
{
	assert(table);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_table() enter: "
		"table=%p\n",table);

	params->ctc_table = *table;
	params->ctc_table_changed = true;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_table() leave: "
		"return_void\n");
}

static void
sh_css_get_ctc_table(const struct ia_css_isp_parameters *params,
			struct ia_css_ctc_table *table)
{
	assert(table != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_table() enter: "
		"table=%p\n",table);

	*table = params->ctc_table;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_table() leave: "
		"*table=%p\n",*table);
}

static void
sh_css_set_xnr_table(struct ia_css_isp_parameters *params,
			const struct ia_css_xnr_table *table)
{
	assert(table);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_xnr_table() enter: "
		"table=%p\n",table);

	params->xnr_table = *table;
	params->xnr_table_changed = true;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_xnr_table() leave: "
		"return_void\n");
}

static void
sh_css_get_xnr_table(const struct ia_css_isp_parameters *params,
			struct ia_css_xnr_table *table)
{
	assert(table != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_table() enter: "
		"table=%p\n",table);

	*table = params->xnr_table;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_xnr_table() leave: "
		"*table=%p\n",*table);
}

static void
sh_css_set_macc_table(struct ia_css_isp_parameters *params,
			const struct ia_css_macc_table *table)
{
	assert(table);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_table() enter: "
		"table=%p\n",table);

	params->macc_table = *table;
	params->macc_table_changed = true;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_table() leave: "
		"return_void\n");
}

static void
sh_css_get_macc_table(const struct ia_css_isp_parameters *params,
			struct ia_css_macc_table *table)
{
	assert(table != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_table() enter: "
		"table=%p\n",table);

	*table = params->macc_table;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_table() leave: "
		"*table=%p\n",*table);
}

static void
sh_css_set_anr_thres(struct ia_css_isp_parameters *params,
			const struct ia_css_anr_thres *thres)
{
	assert(thres);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_thres() enter: "
		"thres=%p\n",thres);

	params->anr_thres = *thres;
	params->anr_thres_changed = true;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_thres() leave: "
		"return_void\n");
}

static void
sh_css_get_anr_thres(const struct ia_css_isp_parameters *params,
			struct ia_css_anr_thres *thres)
{
	assert(thres != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_thres() enter: "
		"thres=%p\n",thres);

	*thres = params->anr_thres;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_thres() leave: "
		"*thres=%p\n",*thres);
}

void ia_css_morph_table_free(
	struct ia_css_morph_table *me)
{
	unsigned int i;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_morph_table_free() enter:\n");

	if (me == NULL) {
/* Checkpatch patch */
		return;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		if (me->coordinates_x[i])
			sh_css_free(me->coordinates_x[i]);
		if (me->coordinates_y[i])
			sh_css_free(me->coordinates_y[i]);
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_morph_table_free() leave:\n");

	sh_css_free(me);
}

struct ia_css_morph_table *ia_css_morph_table_allocate(
	unsigned int width,
	unsigned int height)
{
	unsigned int i;
	struct ia_css_morph_table *me = sh_css_malloc(sizeof(*me));

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_morph_table_allocate() enter:\n");

	if (me == NULL) {
/* Checkpatch patch */
		return me;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		me->coordinates_x[i] = NULL;
		me->coordinates_y[i] = NULL;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		me->coordinates_x[i] =
		    sh_css_malloc(height * width *
				  sizeof(*me->coordinates_x[i]));
		me->coordinates_y[i] =
		    sh_css_malloc(height * width *
				  sizeof(*me->coordinates_y[i]));

		if ((me->coordinates_x[i] == NULL) ||
			(me->coordinates_y[i] == NULL)) {
/*
 * MW: Potential memory leak, need to free all previous pointers
 *
			sh_css_free(me->coordinates_x[i]);
			sh_css_free(me->coordinates_y[i]);
 */
			ia_css_morph_table_free(me);
			me = NULL;
			return me;
		}
	}
	me->width = width;
	me->height = height;

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_morph_table_allocate() leave:\n");

	return me;
}

static enum ia_css_err sh_css_params_default_morph_table(
	struct ia_css_morph_table **table,
	const struct sh_css_binary *binary)
{
/* MW 2400 advanced requires different scaling */
	unsigned int i, j, k,
		     step = (ISP_VEC_NELEMS / 16) * 128,
		     width = binary->morph_tbl_width,
		     height = binary->morph_tbl_height;
	short start_x[IA_CSS_MORPH_TABLE_NUM_PLANES] = { -8, 0, -8, 0, 0, -8 },
	      start_y[IA_CSS_MORPH_TABLE_NUM_PLANES] = { 0, 0, -8, -8, -8, 0 };
	struct ia_css_morph_table *tab;

assert(table != NULL);
assert(binary != NULL);
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_default_morph_table() enter:\n");

	tab = ia_css_morph_table_allocate(width, height);
	if (tab == NULL) {

		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
	}

	for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
		short val_y = start_y[i];
		for (j = 0; j < height; j++) {
			short val_x = start_x[i];
			unsigned short *x_ptr, *y_ptr;

			x_ptr = &tab->coordinates_x[i][j * width];
			y_ptr = &tab->coordinates_y[i][j * width];
			for (k = 0; k < width;
			     k++, x_ptr++, y_ptr++, val_x += step) {
				if (k == 0)
					*x_ptr = 0;
				else if (k == width - 1)
					*x_ptr = val_x + 2 * start_x[i];
				else
					*x_ptr = val_x;
				if (j == 0)
					*y_ptr = 0;
				else
					*y_ptr = val_y;
			}
			val_y += step;
		}
	}
	*table = tab;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_default_morph_table() leave:\n");

	return IA_CSS_SUCCESS;
}

static void
sh_css_set_morph_table(struct ia_css_isp_parameters *params,
			const struct ia_css_morph_table *table)
{
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_morph_table() enter: "
		"table=%p\n",table);

	if (table->enable == false)
		table = NULL;
	params->morph_table = table;
	params->morph_table_changed = true;
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_morph_table() leave: "
		"return_void\n");
}
#if 0
/* TODO: connect this properly. The table would have to be copied
 * out.
 * */
static void
sh_css_get_morph_table(struct ia_css_isp_parameters *params,
			const struct ia_css_morph_table **table)
{
	assert(table != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_morph_table() enter: "
		"table=%p\n",table);

	*table = params->morph_table;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_morph_table() leave: "
		"*table=%p\n",*table);

}
#endif

void
ia_css_get_3a_statistics(struct ia_css_3a_statistics           *host_stats,
			 const struct ia_css_isp_3a_statistics *isp_stats)
{
	assert(host_stats != NULL);
	assert(isp_stats != NULL);

	sh_css_dtrace(SH_DBG_TRACE,
		"ia_css_get_3a_statistics() enter: "
		"host_stats=%p, isp_stats=%p\n",
		host_stats, isp_stats);

	if (host_stats->grid.use_dmem) {
		get_3a_stats_from_dmem(host_stats,
				       isp_stats->data.dmem.s3a_tbl);
	} else {
		get_3a_stats_from_vmem(host_stats,
				       isp_stats->data.vmem.s3a_tbl_hi,
				       isp_stats->data.vmem.s3a_tbl_lo);
	}
#if !defined(HAS_NO_HMEM)
		get_3a_stats_from_hmem(host_stats,
				       isp_stats->data_hmem.rgby_tbl);
#endif

	sh_css_dtrace(SH_DBG_TRACE,
		"ia_css_get_3a_statistics() leave: return_void\n");
}

static void
sh_css_set_3a_config(struct ia_css_isp_parameters *params,
			const struct ia_css_3a_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_3a_config() enter: "
		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, "
		"config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, "
		"config.awb_lg_low=%d, config.awb_lg_high=%d\n",
		config->ae_y_coef_r, config->ae_y_coef_g,
		config->ae_y_coef_b, config->awb_lg_high_raw,
		config->awb_lg_low, config->awb_lg_high);

	params->s3a_config = *config;
	params->s3a_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_3a_config() leave: "
		"return_void\n");
}

static void
sh_css_get_3a_config(const struct ia_css_isp_parameters *params,
			struct ia_css_3a_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_3a_config() enter: "
		"config=%p\n",config);

	*config = params->s3a_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_3a_config() leave: "
		"config.ae_y_coef_r=%d, config.ae_y_coef_g=%d, "
		"config.ae_y_coef_b=%d, config.awb_lg_high_raw=%d, "
		"config.awb_lg_low=%d,  config.awb_lg_high=%d\n",
		config->ae_y_coef_r, config->ae_y_coef_g,
		config->ae_y_coef_b, config->awb_lg_high_raw,
		config->awb_lg_low, config->awb_lg_high);
}

static void
sh_css_set_wb_config(struct ia_css_isp_parameters *params,
			const struct ia_css_wb_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_wb_config() enter: "
		"config.integer_bits=%d, "
		"config.gr=%d, config.r=%d, "
		"config.b=%d, config.gb=%d\n",
		config->integer_bits,
		config->gr, config->r,
		config->b, config->gb);
	params->wb_config = *config;
	params->wb_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_wb_config() leave: "
		"return_void\n");
}

static void
sh_css_get_wb_config(const struct ia_css_isp_parameters *params,
			struct ia_css_wb_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_wb_config() enter: "
		"config=%p\n",config);

	*config = params->wb_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_wb_config() leave: "
		"config.integer_bits=%d, "
		"config.gr=%d, config.r=%d, "
		"config.b=%d,  config.gb=%d\n",
		config->integer_bits,
		config->gr, config->r,
		config->b, config->gb);
}

static void
sh_css_set_cc_config(struct ia_css_isp_parameters *params,
			const struct ia_css_cc_config *config)
{
	assert (config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cc_config() enter: "
		"config.fraction_bits=%d, config.m[0]=%d, "
		"config.m[1]=%d, config.m[2]=%d, "
		"config.m[3]=%d, config.m[4]=%d, "
		"config.m[5]=%d, config.m[6]=%d, "
		"config.m[7]=%d, config.m[8]=%d\n",
		config->fraction_bits, config->matrix[0],
		config->matrix[1], config->matrix[2],
		config->matrix[3], config->matrix[4],
		config->matrix[5], config->matrix[6],
		config->matrix[7], config->matrix[8]);

/* Copy the values */
	params->cc_config[CSC_KERNEL_PARAM_SET0] = *config;
	params->cc_config_changed[CSC_KERNEL_PARAM_SET0] = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_cc_config() leave: "
		"return_void\n");
}

static void
sh_css_get_cc_config(const struct ia_css_isp_parameters *params,
			struct ia_css_cc_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cc_config() enter: "
		"config=%p\n",config);

	*config = params->cc_config[CSC_KERNEL_PARAM_SET0];

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cc_config() leave: "
		"config.fraction_bits=%d, config.m[0]=%d, "
		"config.m[1]=%d, config.m[2]=%d, "
		"config.m[3]=%d, config.m[4]=%d, "
		"config.m[5]=%d, config.m[6]=%d, "
		"config.m[7]=%d, config.m[8]=%d\n",
		config->fraction_bits, config->matrix[0],
		config->matrix[1], config->matrix[2],
		config->matrix[3], config->matrix[4],
		config->matrix[5], config->matrix[6],
		config->matrix[7], config->matrix[8]);
}

static void
sh_css_set_tnr_config(struct ia_css_isp_parameters *params,
			const struct ia_css_tnr_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_tnr_config() enter: "
		"config.gain=%d, "
		"config.threshold_y=%d, config.threshold_uv=%d\n",
		config->gain,
		config->threshold_y, config->threshold_uv);
	params->tnr_config = *config;
	params->tnr_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_tnr_config() leave: "
		"return_void\n");
}

static void
sh_css_get_tnr_config(const struct ia_css_isp_parameters *params,
			struct ia_css_tnr_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_tnr_config() enter: "
		"config=%p\n",config);

	*config = params->tnr_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_tnr_config() leave: "
		"config.gain=%d, "
		"config.threshold_y=%d, config.threshold_uv=%d\n",
		config->gain,
		config->threshold_y, config->threshold_uv);
}

static void
sh_css_set_ob_config(struct ia_css_isp_parameters *params,
			const struct ia_css_ob_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ob_config() enter: "
		"config.mode=%d, "
		"config.level_gr=%d, config.level_r=%d, "
		"config.level_b=%d,  config.level_gb=%d, "
		"config.start_position=%d, config.end_position=%d\n",
		config->mode,
		config->level_gr, config->level_r,
		config->level_b, config->level_gb,
		config->start_position, config->end_position);

	params->ob_config = *config;
	params->ob_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_ob_config() leave: "
		"return_void\n");
}

static void
sh_css_get_ob_config(const struct ia_css_isp_parameters *params,
			struct ia_css_ob_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ob_config() enter: "
		"config=%p\n",config);

	*config = params->ob_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ob_config() leave: "
		"config.mode=%d, "
		"config.level_gr=%d, config.level_r=%d, "
		"config.level_b=%d,  config.level_gb=%d, "
		"config.start_position=%d, config.end_position=%d\n",
		config->mode,
		config->level_gr, config->level_r,
		config->level_b,  config->level_gb,
		config->start_position, config->end_position);
}

static void
sh_css_set_dp_config(struct ia_css_isp_parameters *params,
			const struct ia_css_dp_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dp_config() enter: "
		"config.threshold=%d, config.gain=%d\n",
		config->threshold, config->gain);
	params->dp_config = *config;
	params->dp_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_dp_config() leave: "
		"return_void\n");
}

static void
sh_css_get_dp_config(const struct ia_css_isp_parameters *params,
			struct ia_css_dp_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dp_config() enter: "
		"config=%p\n",config);

	*config = params->dp_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dp_config() enter: "
		"config.threshold=%d, config.gain=%d\n",
		config->threshold, config->gain);
}

static void
sh_css_set_nr_config(struct ia_css_isp_parameters *params,
			const struct ia_css_nr_config *config)
{
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_nr_config() enter: "
		"config.direction=%d, "
		"config.bnr_gain=%d, config.ynr_gain=%d, "
		"config.threshold_cb=%d, config.threshold_cr=%d\n",
		config->direction,
		config->bnr_gain, config->ynr_gain,
		config->threshold_cb, config->threshold_cr);
	params->nr_config = *config;
	params->nr_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_nr_config() leave: "
		"return_void\n");
}

static void
sh_css_get_nr_config(const struct ia_css_isp_parameters *params,
			struct ia_css_nr_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_nr_config() enter: "
		"config=%p\n",config);

	*config = params->nr_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_nr_config() leave: "
		"config.direction=%d, "
		"config.bnr_gain=%d, config.ynr_gain=%d, "
		"config.threshold_cb=%d, config.threshold_cr=%d\n",
		config->direction,
		config->bnr_gain, config->ynr_gain,
		config->threshold_cb, config->threshold_cr);
}

static void
sh_css_set_ee_config(struct ia_css_isp_parameters *params,
			const struct ia_css_ee_config *config)
{
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ee_config() enter: "
		"config.threshold=%d, "
		"config.gain=%d, config.detail_gain=%d\n",
		config->threshold,
		config->gain, config->detail_gain);
	params->ee_config = *config;
	params->ee_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_ee_config() leave: "
		"return_void\n");
}

static void
sh_css_get_ee_config(const struct ia_css_isp_parameters *params,
			struct ia_css_ee_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ee_config() enter: "
		"config=%p\n",config);

	*config = params->ee_config;
	
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ee_config() enter: "
		"config.threshold=%d, "
		"config.gain=%d, config.detail_gain=%d\n",
		config->threshold,
		config->gain, config->detail_gain);
}

static void
sh_css_set_de_config(struct ia_css_isp_parameters *params,
			const struct ia_css_de_config *config)
{
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_de_config() enter: "
		"config.pixelnoise=%d, "
		"config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
		config->pixelnoise,
		config->c1_coring_threshold, config->c2_coring_threshold);
	params->de_config = *config;
	params->de_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_de_config() leave: "
		"return_void\n");
}

static void
sh_css_get_de_config(const struct ia_css_isp_parameters *params,
			struct ia_css_de_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_de_config() enter: "
		"config=%p\n",config);

	*config = params->de_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_de_config() leave: "
		"config.pixelnoise=%d, "
		"config.c1_coring_threshold=%d, config.c2_coring_threshold=%d\n",
		config->pixelnoise,
		config->c1_coring_threshold,
		config->c2_coring_threshold);
}

static void
sh_css_set_gc_config(struct ia_css_isp_parameters *params,
			const struct ia_css_gc_config *config)
{
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_gc_config() enter: "
		"config.gain_k1=%d, config.gain_k2=%d\n",
		config->gain_k1, config->gain_k2);
	params->gc_config = *config;
	params->gc_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_gc_config() leave: "
		"return_void\n");
}

static void
sh_css_get_gc_config(const struct ia_css_isp_parameters *params,
			struct ia_css_gc_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gc_config() enter: "
		"config=%p\n",config);

	*config = params->gc_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_gc_config() leave: "
		"config.gain_k1=%d, config.gain_k2=%d\n",
		config->gain_k1, config->gain_k2);
}

static void
sh_css_set_anr_config(struct ia_css_isp_parameters *params,
			const struct ia_css_anr_config *config)
{
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_anr_config() enter: "
		"config.threshold=%d\n",
		config->threshold);
	params->anr_config = *config;
	params->anr_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_anr_config() leave: "
		"return_void\n");
}

static void
sh_css_get_anr_config(const struct ia_css_isp_parameters *params,
			struct ia_css_anr_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_config() enter: "
		"config=%p\n",config);

	*config = params->anr_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_anr_config() leave: "
		"config.threshold=%d\n",
		config->threshold);
}

static void
sh_css_set_ce_config(struct ia_css_isp_parameters *params,
			const struct ia_css_ce_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ce_config() enter: "
		"config.uv_level_min=%d, config.uv_level_max=%d\n",
		config->uv_level_min, config->uv_level_max);
	params->ce_config = *config;
	params->ce_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_ce_config() leave: "
		"return_void\n");
}

static void
sh_css_get_ce_config(const struct ia_css_isp_parameters *params,
			struct ia_css_ce_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ce_config() enter: "
		"config=%p\n",config);

	*config = params->ce_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ce_config() leave: "
		"config.uv_level_min=%d, config.uv_level_max=%d\n",
		config->uv_level_min, config->uv_level_max);
}

static void
sh_css_set_dvs_6axis_config(struct ia_css_isp_parameters *params,
			   const struct ia_css_dvs_6axis_config  *dvs_config)
{
	
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_dvs_config() enter: "
	"dvs_config=%p\n",dvs_config);

	assert(dvs_config != NULL);
	assert(dvs_config->height_y == dvs_config->height_uv);
	assert( (dvs_config->width_y - 1) == 2 * dvs_config->width_uv - 1);

	copy_dvs_6axis_table(params->dvs_6axis_config,dvs_config);
	
	params->dvs_6axis_config_changed = true;	
	
	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_dvs_6axis_config() leave: "
		"return_void\n");
	
}

static void
sh_css_get_dvs_6axis_config(const struct ia_css_isp_parameters *params,
				struct ia_css_dvs_6axis_config *dvs_config)
{
	assert(dvs_config != NULL);
	assert(dvs_config->height_y == dvs_config->height_uv);
	assert( (dvs_config->width_y - 1) == 2 * dvs_config->width_uv - 1);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dvs_6axis_config() enter: "
		"dvs_config=%p\n",dvs_config);
	
	if((dvs_config->width_y == params->dvs_6axis_config->width_y) &&
	(dvs_config->height_y == params->dvs_6axis_config->height_y) &&
	(dvs_config->width_uv == params->dvs_6axis_config->width_uv) &&
	(dvs_config->height_uv == params->dvs_6axis_config->height_uv) &&
	dvs_config->xcoords_y &&
        dvs_config->ycoords_y &&
        dvs_config->xcoords_uv &&
	dvs_config->ycoords_uv)
	{
		copy_dvs_6axis_table(dvs_config,params->dvs_6axis_config);
	}
	
	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_get_dvs_6axis_config() leave: "
		"return_void\n");	
}

static void
sh_css_set_ecd_config(struct ia_css_isp_parameters *params,
			const struct ia_css_ecd_config *config)
{
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config()\n");
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ynr_config() enter: "
		"config.zip_strength=%d, "
		"config.fc_strength=%d, config.fc_debias=%d\n",
		config->zip_strength,
		config->fc_strength, config->fc_debias);
	params->ecd_config = *config;
	params->ecd_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config() leave: "
		"return_void\n");
}

static void
sh_css_get_ecd_config(const struct ia_css_isp_parameters *params,
			struct ia_css_ecd_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ecd_config() enter: "
		"config=%p\n",config);

	*config = params->ecd_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ecd_config() enter: "
		"config.zip_strength=%d, "
		"config.fc_strength=%d, config.fc_debias=%d\n",
		config->zip_strength,
		config->fc_strength, config->fc_debias);
}

static void
sh_css_set_ynr_config(struct ia_css_isp_parameters *params,
			const struct ia_css_ynr_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ynr_config() enter: "
		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, "
		"config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
		config->edge_sense_gain_0, config->edge_sense_gain_1,
		config->corner_sense_gain_0, config->corner_sense_gain_1);

	params->ynr_config = *config;
	params->ynr_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_ynr_config() leave: "
		"return_void\n");
}

static void
sh_css_get_ynr_config(const struct ia_css_isp_parameters *params,
			struct ia_css_ynr_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ynr_config() enter: "
		"config=%p\n",config);

	*config = params->ynr_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ynr_config() leave: "
		"config.edge_sense_gain_0=%d, config.edge_sense_gain_1=%d, "
		"config.corner_sense_gain_0=%d, config.corner_sense_gain_1=%d\n",
		config->edge_sense_gain_0, config->edge_sense_gain_1,
		config->corner_sense_gain_0, config->corner_sense_gain_1);
}

static void
sh_css_set_fc_config(struct ia_css_isp_parameters *params,
			const struct ia_css_fc_config *config)
{
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_fc_config() enter: "
		"config.gain_exp=%d, "
		"config.gain_pos_0=%d, config.gain_pos_1=%d, "
		"config.gain_neg_0=%d, config.gain_neg_1=%d, "
		"config.crop_pos_0=%d, config.crop_pos_1=%d, "
		"config.crop_neg_0=%d, config.crop_neg_1=%d\n",
		config->gain_exp,
		config->gain_pos_0, config->gain_pos_1,
		config->gain_neg_0, config->gain_neg_1,
		config->crop_pos_0, config->crop_pos_1,
		config->crop_neg_0, config->crop_neg_1);
	params->fc_config = *config;
	params->fc_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_fc_config() leave: "
		"return_void\n");
}

static void
sh_css_get_fc_config(const struct ia_css_isp_parameters *params,
			struct ia_css_fc_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_fc_config() enter: "
		"config=%p\n",config);

	*config = params->fc_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_fc_config() leave: "
		"config.gain_exp=%d, "
		"config.gain_pos_0=%d, config.gain_pos_1=%d, "
		"config.gain_neg_0=%d, config.gain_neg_1=%d, "
		"config.crop_pos_0=%d, config.crop_pos_1=%d, "
		"config.crop_neg_0=%d, config.crop_neg_1=%d\n",
		config->gain_exp,
		config->gain_pos_0, config->gain_pos_1,
		config->gain_neg_0, config->gain_neg_1,
		config->crop_pos_0, config->crop_pos_1,
		config->crop_neg_0, config->crop_neg_1);
}

static void
sh_css_set_cnr_config(struct ia_css_isp_parameters *params,
			const struct ia_css_cnr_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_cnr_config() enter: "
		"config.coring_u=%d, config.coring_v=%d, "
		"config.sense_gain_vy=%d, config.sense_gain_hy=%d, "
		"config.sense_gain_vu=%d, config.sense_gain_hu=%d, "
		"config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
		config->coring_u, config->coring_v,
		config->sense_gain_vy, config->sense_gain_hy,
		config->sense_gain_vu, config->sense_gain_hu,
		config->sense_gain_vv, config->sense_gain_hv);

	params->cnr_config = *config;
	params->cnr_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_cnr_config() leave: "
		"return_void\n");
}

static void
sh_css_get_cnr_config(const struct ia_css_isp_parameters *params,
			struct ia_css_cnr_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cnr_config() enter: "
		"config=%p\n",config);

	*config = params->cnr_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_cnr_config() leave: "
		"config.coring_u=%d, config.coring_v=%d, "
		"config.sense_gain_vy=%d, config.sense_gain_hy=%d, "
		"config.sense_gain_vu=%d, config.sense_gain_hu=%d, "
		"config.sense_gain_vv=%d, config.sense_gain_hv=%d\n",
		config->coring_u, config->coring_v,
		config->sense_gain_vy, config->sense_gain_hy,
		config->sense_gain_vu, config->sense_gain_hu,
		config->sense_gain_vv, config->sense_gain_hv);
}

static void
sh_css_set_macc_config(struct ia_css_isp_parameters *params,
			const struct ia_css_macc_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_macc_config() enter: "
		"config.exp=%d\n",
		config->exp);
	params->macc_config = *config;
	params->macc_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_macc_config() leave: "
		"return_void\n");
}

static void
sh_css_get_macc_config(const struct ia_css_isp_parameters *params,
			struct ia_css_macc_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_config() enter: "
		"config=%p\n",config);

	*config = params->macc_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_macc_config() leave: "
		"config.exp=%d\n",
		config->exp);
}

static void
sh_css_set_ctc_config(struct ia_css_isp_parameters *params,
			const struct ia_css_ctc_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_ctc_config() enter: "
		"config.ce_gain_exp=%d, config.y0=%d, "
		"config.x1=%d, config.y1=%d, "
		"config.x2=%d, config.y2=%d, "
		"config.x3=%d, config.y3=%d, "
		"config.x4=%d, config.y4=%d\n",
		config->ce_gain_exp, config->y0,
		config->x1, config->y1,
		config->x2, config->y2,
		config->x3, config->y3,
		config->x4, config->y4);

	params->ctc_config = *config;
	params->ctc_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_ctc_config() leave: "
		"return_void\n");
}

static void
sh_css_get_ctc_config(const struct ia_css_isp_parameters *params,
			struct ia_css_ctc_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_config() enter: "
		"config=%p\n",config);

	*config = params->ctc_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_ctc_config() leave: "
		"config.ce_gain_exp=%d, config.y0=%d, "
		"config.x1=%d, config.y1=%d, "
		"config.x2=%d, config.y2=%d, "
		"config.x3=%d, config.y3=%d, "
		"config.x4=%d, config.y4=%d\n",
		config->ce_gain_exp, config->y0,
		config->x1, config->y1,
		config->x2, config->y2,
		config->x3, config->y3,
		config->x4, config->y4);
}

static void
sh_css_set_aa_config(struct ia_css_isp_parameters *params,
			const struct ia_css_aa_config *config)
{
	assert (config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_aa_config() enter: "
		"config.scale=%d\n",
		config->scale);

	params->aa_config = *config;
	params->aa_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_aa_config() leave: "
		"return_void\n");
}

static void
sh_css_get_aa_config(const struct ia_css_isp_parameters *params,
			struct ia_css_aa_config *config)
{
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_aa_config() enter: "
		"config=%p\n",config);

	*config = params->aa_config;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_aa_config() leave: "
		"config.scale=%d\n",
		config->scale);
}

static void
sh_css_set_r_gamma_table(struct ia_css_isp_parameters *params,
				const struct ia_css_rgb_gamma_table *table)
{
	assert(table);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_r_gamma_table() enter: "
		"table=%p\n",table);

	params->r_gamma_table = *table;
	params->r_gamma_table_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_r_gamma_table() leave: "
		"return_void\n");
}

static void
sh_css_get_r_gamma_table(const struct ia_css_isp_parameters *params,
			struct ia_css_rgb_gamma_table *table)
{
	assert(table != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_r_gamma_table() enter:\n");

	*table = params->r_gamma_table;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_r_gamma_table() leave: "
		"*table=%p\n",*table);
}

static void
sh_css_set_g_gamma_table(struct ia_css_isp_parameters *params,
			const struct ia_css_rgb_gamma_table *table)
{
	assert(table);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_g_gamma_table() enter: "
		"table=%p\n",table);

	params->g_gamma_table = *table;
	params->g_gamma_table_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_g_gamma_table() leave: "
		"return_void\n");
}

static void
sh_css_get_g_gamma_table(const struct ia_css_isp_parameters *params,
			struct ia_css_rgb_gamma_table *table)
{
	assert(table != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() enter:\n");

	*table = params->g_gamma_table;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() leave: "
		"*table=%p\n",*table);
}

static void
sh_css_set_b_gamma_table(struct ia_css_isp_parameters *params,
			const struct ia_css_rgb_gamma_table *table)
{
	assert(table);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_b_gamma_table() enter: "
		"table=%p\n",table);

	params->b_gamma_table = *table;
	params->b_gamma_table_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_b_gamma_table() leave: "
		"return_void\n");
}

static void
sh_css_get_b_gamma_table(const struct ia_css_isp_parameters *params,
			struct ia_css_rgb_gamma_table *table)
{
	assert(table != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_b_gamma_table() enter:\n");

	*table = params->b_gamma_table;
	
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_g_gamma_table() leave: "
		"*table=%p\n",*table);
}

static void
sh_css_set_yuv2rgb_cc_config(
	struct ia_css_isp_parameters *params,
	const struct ia_css_cc_config *config)
{
	assert(params != NULL);
	assert (config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_yuv2rgb_cc_config() enter: "
		"config.m[0]=%d, "
		"config.m[1]=%d, config.m[2]=%d, "
		"config.m[3]=%d, config.m[4]=%d, "
		"config.m[5]=%d, config.m[6]=%d, "
		"config.m[7]=%d, config.m[8]=%d\n",
		config->matrix[0],
		config->matrix[1], config->matrix[2],
		config->matrix[3], config->matrix[4],
		config->matrix[5], config->matrix[6],
		config->matrix[7], config->matrix[8]);
/*
	params->yuv2rgb_cc_config = *config;
	params->yuv2rgb_cc_config_changed = true;
 */
	params->cc_config[CSC_KERNEL_PARAM_SET2] = *config;
	params->cc_config_changed[CSC_KERNEL_PARAM_SET2] = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_yuv2rgb_cc_config() leave: "
		"return_void\n");
}

static void
sh_css_get_yuv2rgb_cc_config(
	const struct ia_css_isp_parameters *params,
	struct ia_css_cc_config *config)
{
	assert(params != NULL);
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_yuv2rgb_cc_config() enter:\n");

/*	*config = params->yuv2rgb_cc_config; */
	*config = params->cc_config[CSC_KERNEL_PARAM_SET2];

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_yuv2rgb_cc_config() leave: "
		"config.m[0]=%d, "
		"config.m[1]=%d, config.m[2]=%d, "
		"config.m[3]=%d, config.m[4]=%d, "
		"config.m[5]=%d, config.m[6]=%d, "
		"config.m[7]=%d, config.m[8]=%d\n",
		config->matrix[0],
		config->matrix[1], config->matrix[2],
		config->matrix[3], config->matrix[4],
		config->matrix[5], config->matrix[6],
		config->matrix[7], config->matrix[8]);
}

static void
sh_css_set_rgb2yuv_cc_config(
	struct ia_css_isp_parameters *params,
	const struct ia_css_cc_config *config)
{
	assert(params != NULL);
	assert(config != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_rgb2yuv_cc_config() enter: "
		"config.m[0]=%d, "
		"config.m[1]=%d, config.m[2]=%d, "
		"config.m[3]=%d, config.m[4]=%d, "
		"config.m[5]=%d, config.m[6]=%d, "
		"config.m[7]=%d, config.m[8]=%d\n",
		config->matrix[0],
		config->matrix[1], config->matrix[2],
		config->matrix[3], config->matrix[4],
		config->matrix[5], config->matrix[6],
		config->matrix[7], config->matrix[8]);
/*
	params->rgb2yuv_cc_config = *config;
	params->rgb2yuv_cc_config_changed = true;
 */
	params->cc_config[CSC_KERNEL_PARAM_SET1] = *config;
	params->cc_config_changed[CSC_KERNEL_PARAM_SET1] = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_rgb2yuv_cc_config() leave: "
		"return_void\n");
}

static void
sh_css_get_rgb2yuv_cc_config(
	const struct ia_css_isp_parameters *params,
	struct ia_css_cc_config *config)
{
	assert(params != NULL);
	assert(config != NULL);

/*	*config = params->rgb2yuv_cc_config; */
	*config = params->cc_config[CSC_KERNEL_PARAM_SET1];

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_rgb2yuv_cc_config() leave: "
		"config.m[0]=%d, "
		"config.m[1]=%d, config.m[2]=%d, "
		"config.m[3]=%d, config.m[4]=%d, "
		"config.m[5]=%d, config.m[6]=%d, "
		"config.m[7]=%d, config.m[8]=%d\n",
		config->matrix[0],
		config->matrix[1], config->matrix[2],
		config->matrix[3], config->matrix[4],
		config->matrix[5], config->matrix[6],
		config->matrix[7], config->matrix[8]);
}

static void
sh_css_set_dz_config(struct ia_css_isp_parameters *params,
			const struct ia_css_dz_config *config)
{
	assert(config);
	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_zoom_factor() enter: dx=%d, dy=%d\n",
		config->dx, config->dy);

	assert(config->dx <= HRT_GDC_N);
	assert(config->dy <= HRT_GDC_N);

	params->dz_config = *config;
	params->dz_config_changed = true;
	/* JK: Why isp params changed?? */
	params->isp_params_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_zoom_factor() leave: "
		"return_void\n");
}

static void
sh_css_get_dz_config(const struct ia_css_isp_parameters *params,
			struct ia_css_dz_config *config)
{
	assert(config);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_dz_config() enter:\n");

	*config = params->dz_config;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_get_dz_config() leave: dx=%d, dy=%d\n",
		config->dx, config->dy);
}

static void
sh_css_set_motion_vector(struct ia_css_isp_parameters *params,
			const struct ia_css_vector *motion)
{
	assert(motion);
	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_motion_vector() enter: x=%d, y=%d\n",
		motion->x, motion->y);

	params->motion_config = *motion;
	/* JK: Why do isp params change? */
	params->motion_config_changed = true;
	params->isp_params_changed = true;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_motion_vector() leave: "
		"return_void\n");
}

static void
sh_css_get_motion_vector(const struct ia_css_isp_parameters *params,
			struct ia_css_vector *motion)
{
	assert(motion);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_motion_vector() enter\n");

	*motion = params->motion_config;

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_get_motion_vector() leave: x=%d, y=%d\n",
		motion->x, motion->y);
}

/* TODO: make a direct implementation and remove the partial ones */
void
ia_css_stream_set_isp_config(
	struct ia_css_stream *stream,
	const struct ia_css_isp_config *config)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_set_isp_config() enter: "
		"stream=%p, config=%p\n", stream, config);

	if (config->wb_config)
		sh_css_set_wb_config(params, config->wb_config);
	if (config->cc_config)
		sh_css_set_cc_config(params, config->cc_config);
	if (config->tnr_config)
		sh_css_set_tnr_config(params, config->tnr_config);
	if (config->ob_config)
		sh_css_set_ob_config(params, config->ob_config);
	if (config->nr_config)
		sh_css_set_nr_config(params, config->nr_config);
	if (config->ee_config)
		sh_css_set_ee_config(params, config->ee_config);
	if (config->de_config)
		sh_css_set_de_config(params, config->de_config);
	if (config->gc_config)
		sh_css_set_gc_config(params, config->gc_config);
	if (config->ecd_config)
		sh_css_set_ecd_config(params, config->ecd_config);
	if (config->ynr_config)
		sh_css_set_ynr_config(params, config->ynr_config);
	if (config->fc_config)
		sh_css_set_fc_config(params, config->fc_config);
	if (config->cnr_config)
		sh_css_set_cnr_config(params, config->cnr_config);
	if (config->macc_config)
		sh_css_set_macc_config(params, config->macc_config);
	if (config->ctc_config)
		sh_css_set_ctc_config(params, config->ctc_config);
	if (config->aa_config)
		sh_css_set_aa_config(params, config->aa_config);
	if (config->ce_config)
		sh_css_set_ce_config(params, config->ce_config);
	if (config->dvs_6axis_config)
		sh_css_set_dvs_6axis_config(params, config->dvs_6axis_config);
	if (config->yuv2rgb_cc_config)
		sh_css_set_yuv2rgb_cc_config(params, config->yuv2rgb_cc_config);
	if (config->rgb2yuv_cc_config)
		sh_css_set_rgb2yuv_cc_config(params, config->rgb2yuv_cc_config);
	if (config->anr_config)
		sh_css_set_anr_config(params, config->anr_config);
	if (config->s3a_config)
		sh_css_set_3a_config(params, config->s3a_config);
	if (config->macc_table)
		sh_css_set_macc_table(params, config->macc_table);
	if (config->gamma_table)
		sh_css_set_gamma_table(params, config->gamma_table);
	if (config->ctc_table)
		sh_css_set_ctc_table(params, config->ctc_table);
	if (config->xnr_table)
		sh_css_set_xnr_table(params, config->xnr_table);
	if (config->r_gamma_table)
		sh_css_set_r_gamma_table(params, config->r_gamma_table);
	if (config->g_gamma_table)
		sh_css_set_g_gamma_table(params, config->g_gamma_table);
	if (config->b_gamma_table)
		sh_css_set_b_gamma_table(params, config->b_gamma_table);
	if (config->dz_config)
		sh_css_set_dz_config(params, config->dz_config);
	if (config->motion_vector)
		sh_css_set_motion_vector(params, config->motion_vector);
	if (config->shading_table)
		sh_css_set_shading_table(stream, config->shading_table);
	if (config->morph_table)
		sh_css_set_morph_table(params, config->morph_table);
	if (config->dvs_coefs)
		ia_css_set_dvs_coefficients(params, config->dvs_coefs);
	if (config->dvs2_coefs)
		ia_css_set_dvs2_coefficients(params, config->dvs2_coefs);
	/*
	   if (config->_config)
	   sh_css_set_xnr_config(config->xnr_config);
	*/
	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_set_isp_config() leave: "
		"return_void\n");

	/* Now commit all changes to the SP */
	sh_css_param_update_isp_params(stream, sh_css_sp_is_running());
}

/* TODO: make a direct implementation and remove the partial ones */
void
ia_css_stream_get_isp_config(
	const struct ia_css_stream *stream,
	struct ia_css_isp_config *config)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	assert(config != NULL);
	sh_css_dtrace(SH_DBG_TRACE, "sh_css_get_isp_config() enter: "
		"config=%p\n", config);

	(void) stream;

	if (config->wb_config)
		sh_css_get_wb_config(params, config->wb_config);
	if (config->cc_config)
		sh_css_get_cc_config(params, config->cc_config);
	if (config->tnr_config)
		sh_css_get_tnr_config(params, config->tnr_config);
	if (config->ob_config)
		sh_css_get_ob_config(params, config->ob_config);
	if (config->dp_config)
		sh_css_get_dp_config(params, config->dp_config);
	if (config->nr_config)
		sh_css_get_nr_config(params, config->nr_config);
	if (config->ee_config)
		sh_css_get_ee_config(params, config->ee_config);
	if (config->de_config)
		sh_css_get_de_config(params, config->de_config);
	if (config->gc_config)
		sh_css_get_gc_config(params, config->gc_config);
	if (config->anr_config)
		sh_css_get_anr_config(params, config->anr_config);
	if (config->s3a_config)
		sh_css_get_3a_config(params, config->s3a_config);
	if (config->ecd_config)
		sh_css_get_ecd_config(params, config->ecd_config);
	if (config->ynr_config)
		sh_css_get_ynr_config(params, config->ynr_config);
	if (config->fc_config)
		sh_css_get_fc_config(params, config->fc_config);
	if (config->cnr_config)
		sh_css_get_cnr_config(params, config->cnr_config);
	if (config->macc_config)
		sh_css_get_macc_config(params, config->macc_config);
	if (config->ctc_config)
		sh_css_get_ctc_config(params, config->ctc_config);
	if (config->aa_config)
		sh_css_get_aa_config(params, config->aa_config);
	if (config->ce_config)
		sh_css_get_ce_config(params, config->ce_config);
	if (config->dvs_6axis_config)
		sh_css_get_dvs_6axis_config(params, config->dvs_6axis_config);
	if (config->yuv2rgb_cc_config)
		sh_css_get_yuv2rgb_cc_config(params, config->yuv2rgb_cc_config);
	if (config->rgb2yuv_cc_config)
		sh_css_get_rgb2yuv_cc_config(params, config->rgb2yuv_cc_config);
	if (config->macc_table)
		sh_css_get_macc_table(params, config->macc_table);
	if (config->gamma_table)
		sh_css_get_gamma_table(params, config->gamma_table);
	if (config->ctc_table)
		sh_css_get_ctc_table(params, config->ctc_table);
	if (config->xnr_table)
		sh_css_get_xnr_table(params, config->xnr_table);
	if (config->r_gamma_table)
		sh_css_get_r_gamma_table(params, config->r_gamma_table);
	if (config->g_gamma_table)
		sh_css_get_g_gamma_table(params, config->g_gamma_table);
	if (config->b_gamma_table)
		sh_css_get_b_gamma_table(params, config->b_gamma_table);
	if (config->dz_config)
		sh_css_get_dz_config(params, config->dz_config);
	if (config->motion_vector)
		sh_css_get_motion_vector(params, config->motion_vector);
	if (config->anr_thres)
		sh_css_get_anr_thres(params, config->anr_thres);

/*
	if (config->xnr_config != NULL)
		sh_css_get_xnr_config(config->xnr_config);
*/
	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_get_isp_config() leave: "
		"return_void\n");
}

/*
 * coding style says the return of "mmgr_NULL" is the error signal
 *
 * Deprecated: Implement mmgr_realloc()
 */
static bool realloc_isp_css_mm_buf(
/* STORAGE_CLASS_INLINE bool realloc_isp_css_mm_buf( */
	hrt_vaddress *curr_buf, size_t *curr_size,
	size_t needed_size, bool force, enum ia_css_err *err,
	uint16_t	mmgr_attribute)
{
	int32_t id;
	*err = IA_CSS_SUCCESS;
	/* Possible optimization: add a function sh_css_isp_css_mm_realloc()
	 * and implement on top of hmm. */

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() enter:\n");

	if (!force && *curr_size >= needed_size) {
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
		return false;
	}
	/* don't reallocate if single ref to buffer and same size */
	if (*curr_size == needed_size && sh_css_refcount_is_single(*curr_buf)) {
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
		return false;
	}

	id = PARAM_BUFFER;//sh_css_refcount_get_id(*curr_buf);
	sh_css_refcount_release(id, *curr_buf);
	*curr_buf = sh_css_refcount_retain(id, mmgr_alloc_attr(needed_size,
							mmgr_attribute));

	if (!*curr_buf) {
		*err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
		*curr_size = 0;
	} else {
		*curr_size = needed_size;
	}
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "realloc_isp_css_mm_buf() leave:\n");
	return true;
}

static bool reallocate_buffer(
/* STORAGE_CLASS_INLINE bool reallocate_buffer( */
	hrt_vaddress *curr_buf,
	size_t *curr_size,
	size_t needed_size,
	bool force,
	enum ia_css_err *err)
{
	bool ret;
	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_buffer() enter:\n");

	ret = realloc_isp_css_mm_buf(curr_buf,
		curr_size, needed_size, force, err, mmgr_attribute);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_buffer() leave:\n");
	return ret;
}

#if 0
static bool reallocate_cached_buffer(
/* STORAGE_CLASS_INLINE bool reallocate_cached_buffer( */
	hrt_vaddress *curr_buf,
	size_t *curr_size,
	size_t needed_size,
	enum ia_css_err *err)
{
	bool ret;
	uint16_t	mmgr_attribute = MMGR_ATTRIBUTE_DEFAULT |
		MMGR_ATTRIBUTE_CACHED;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_cached_buffer() enter:\n");

	ret = realloc_isp_css_mm_buf(curr_buf,
		curr_size, needed_size, false, err, mmgr_attribute);
		
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "reallocate_cached_buffer() leave:\n");

	return ret;
}
#endif

struct ia_css_isp_3a_statistics *
ia_css_isp_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
{
	struct ia_css_isp_3a_statistics *me;

assert(grid != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_3a_statistics_allocate() enter: grid=%p\n",grid);

/* MW: Does "grid->enable" also control the histogram output ?? */
	if (!grid->enable)
		return NULL;

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	if (grid->use_dmem) {
		int s3a_table_size = sizeof(struct ia_css_3a_output) *
					grid->aligned_width * 
					grid->aligned_height;
		me->data.dmem.s3a_tbl = mmgr_malloc(s3a_table_size);
		if (me->data.dmem.s3a_tbl == mmgr_NULL)
			goto err;
	} else {
		int s3a_table_size = ISP_S3ATBL_HI_LO_STRIDE_BYTES *
					grid->aligned_height;
		me->data.vmem.s3a_tbl_hi = mmgr_malloc(s3a_table_size);
		if (me->data.vmem.s3a_tbl_hi == mmgr_NULL)
			goto err;
		me->data.vmem.s3a_tbl_lo = mmgr_malloc(s3a_table_size);
		if (me->data.vmem.s3a_tbl_lo == mmgr_NULL)
			goto err;
	}
#if !defined(HAS_NO_HMEM)
	if ((me->data_hmem.rgby_tbl = mmgr_malloc(sizeof_hmem(HMEM0_ID))) == mmgr_NULL)
		goto err;
#else
	me->data_hmem.rgby_tbl = mmgr_NULL;
#endif

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",me);

	return me;

err:
	ia_css_isp_3a_statistics_free(me);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_3a_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}

void
ia_css_isp_3a_statistics_free(struct ia_css_isp_3a_statistics *me)
{
	if (me != NULL) {
/* mmgr_free() accepts (mmgr_)NULL, but the pointer are in a union, don't free twice */
		mmgr_free(me->data.dmem.s3a_tbl);
		me->data.dmem.s3a_tbl = mmgr_NULL;
		mmgr_free(me->data.vmem.s3a_tbl_hi);
		me->data.vmem.s3a_tbl_hi = mmgr_NULL;
		mmgr_free(me->data.vmem.s3a_tbl_lo);
		me->data.vmem.s3a_tbl_lo = mmgr_NULL;
#if !defined(HAS_NO_HMEM)
		mmgr_free(me->data_hmem.rgby_tbl);
		me->data_hmem.rgby_tbl = mmgr_NULL;
#endif
		sh_css_free(me);
	}
}

struct ia_css_isp_dvs_statistics *
ia_css_isp_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_isp_dvs_statistics *me;
	int hor_size, ver_size;

	assert(grid != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs_statistics_allocate() enter: grid=%p\n",grid);

	if (!grid->enable)
		return NULL;

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	hor_size =
		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_height;
	ver_size =
		sizeof(int) * IA_CSS_DVS_NUM_COEF_TYPES * grid->aligned_width;

	me->hor_proj = mmgr_malloc(hor_size);
	if (me->hor_proj == mmgr_NULL)
		goto err;
	me->ver_proj = mmgr_malloc(ver_size);
	if (me->hor_proj == mmgr_NULL)
		goto err;

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",me);

	return me;
err:
	ia_css_isp_dvs_statistics_free(me);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}

void
ia_css_isp_dvs_statistics_free(struct ia_css_isp_dvs_statistics *me)
{
	if (me != NULL) {
		mmgr_free(me->hor_proj);
		mmgr_free(me->ver_proj);
		sh_css_free(me);
	}
}


struct ia_css_isp_dvs_statistics *
ia_css_isp_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_isp_dvs_statistics *me;
	int hor_size, ver_size;

	assert(grid != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs2_statistics_allocate() enter: grid=%p\n",grid);

	if (!grid->enable)
		return NULL;

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	hor_size =
	ver_size = sizeof(int) * IA_CSS_DVS2_NUM_COEF_TYPES
		* grid->aligned_width * grid->aligned_height;

	me->hor_proj = mmgr_malloc(hor_size);
	if (me->hor_proj == mmgr_NULL)
		goto err;
	me->ver_proj = mmgr_malloc(ver_size);
	if (me->hor_proj == mmgr_NULL)
		goto err;

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",me);

	return me;
err:
	ia_css_isp_dvs2_statistics_free(me);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_isp_dvs2_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}

void
ia_css_isp_dvs2_statistics_free(struct ia_css_isp_dvs_statistics *me)
{
	if (me != NULL) {
		mmgr_free(me->hor_proj);
		mmgr_free(me->ver_proj);
		sh_css_free(me);
	}
}

enum ia_css_err
ia_css_stream_isp_parameters_init(struct ia_css_stream *stream)
{
	bool succ = true;
	unsigned i;
	struct sh_css_ddr_address_map *ddr_ptrs;
	struct sh_css_ddr_address_map_size *ddr_ptrs_size;
	struct ia_css_isp_parameters *params;
       
	stream->isp_params_configs = sh_css_calloc(1, sizeof(*stream->isp_params_configs));
	if (!stream->isp_params_configs)
		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;

	params = stream->isp_params_configs;
	ddr_ptrs = &params->ddr_ptrs;
	ddr_ptrs_size = &params->ddr_ptrs_size;

	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
		memset(&params->pipe_ddr_ptrs[i], 0,
			sizeof(params->pipe_ddr_ptrs[i]));
		memset(&params->pipe_ddr_ptrs_size[i], 0,
			sizeof(params->pipe_ddr_ptrs_size[i]));
	}

	memset(ddr_ptrs, 0, sizeof(*ddr_ptrs));
	memset(ddr_ptrs_size, 0, sizeof(*ddr_ptrs_size));

	ddr_ptrs_size->isp_param = sizeof(struct sh_css_isp_params);
	ddr_ptrs->isp_param = sh_css_refcount_retain(PARAM_BUFFER,
				mmgr_malloc(sizeof(struct sh_css_isp_params)));
	succ &= (ddr_ptrs->isp_param != mmgr_NULL);

	ddr_ptrs_size->ctc_tbl = sizeof(struct ia_css_ctc_table);
	ddr_ptrs->ctc_tbl =  sh_css_refcount_retain(PARAM_BUFFER,
				mmgr_malloc(sizeof(struct ia_css_isp_ctc_table)));
	succ &= (ddr_ptrs->ctc_tbl != mmgr_NULL);

	ddr_ptrs_size->gamma_tbl = sizeof(struct ia_css_gamma_table);
	ddr_ptrs->gamma_tbl =  sh_css_refcount_retain(PARAM_BUFFER,
				mmgr_malloc(sizeof(struct ia_css_isp_gamma_table)));
	succ &= (ddr_ptrs->gamma_tbl != mmgr_NULL);

	ddr_ptrs_size->xnr_tbl = sizeof(struct ia_css_xnr_table);
	ddr_ptrs->xnr_tbl =  sh_css_refcount_retain(PARAM_BUFFER,
				mmgr_malloc(sizeof(struct ia_css_isp_xnr_table)));
	succ &= (ddr_ptrs->xnr_tbl != mmgr_NULL);

	ddr_ptrs_size->macc_tbl = sizeof(struct ia_css_macc_table);
	ddr_ptrs->macc_tbl = sh_css_refcount_retain(PARAM_BUFFER,
				mmgr_malloc(sizeof(struct ia_css_macc_table)));
	succ &= (ddr_ptrs->macc_tbl != mmgr_NULL);

	ddr_ptrs_size->r_gamma_tbl = sizeof(struct ia_css_isp_rgb_gamma_table);
	ddr_ptrs->r_gamma_tbl = sh_css_refcount_retain(PARAM_BUFFER,
			mmgr_malloc(sizeof(struct ia_css_isp_rgb_gamma_table)));
	succ &= (ddr_ptrs->r_gamma_tbl != mmgr_NULL);

	ddr_ptrs_size->g_gamma_tbl = sizeof(struct ia_css_isp_rgb_gamma_table);
	ddr_ptrs->g_gamma_tbl = sh_css_refcount_retain(PARAM_BUFFER,
			mmgr_malloc(sizeof(struct ia_css_isp_rgb_gamma_table)));
	succ &= (ddr_ptrs->g_gamma_tbl != mmgr_NULL);

	ddr_ptrs_size->b_gamma_tbl = sizeof(struct ia_css_isp_rgb_gamma_table);
	ddr_ptrs->b_gamma_tbl = sh_css_refcount_retain(PARAM_BUFFER,
			mmgr_malloc(sizeof(struct ia_css_isp_rgb_gamma_table)));
	succ &= (ddr_ptrs->b_gamma_tbl != mmgr_NULL);

	ddr_ptrs_size->anr_thres = sizeof(struct ia_css_anr_thres);
	ddr_ptrs->anr_thres = sh_css_refcount_retain(PARAM_BUFFER,
			mmgr_malloc(sizeof(struct ia_css_anr_thres)));
	succ &= (ddr_ptrs->anr_thres != mmgr_NULL);
 
		
	sh_css_set_3a_config(params, &default_3a_config);
	sh_css_set_wb_config(params, &default_wb_config);
	sh_css_set_cc_config(params, &default_cc_config);
	sh_css_set_tnr_config(params, &default_tnr_config);
	sh_css_set_ob_config(params, &default_ob_config);
	sh_css_set_dp_config(params, &default_dp_config);
	sh_css_set_nr_config(params, &default_nr_config);
	sh_css_set_ee_config(params, &default_ee_config);
	sh_css_set_de_config(params, &default_de_config);
	sh_css_set_gc_config(params, &default_gc_config);
	sh_css_set_anr_config(params, &default_anr_config);
	sh_css_set_ce_config(params, &default_ce_config);
	sh_css_set_macc_table(params, &default_macc_table);
	sh_css_set_gamma_table(params, &default_gamma_table);
	sh_css_set_ctc_table(params, &default_ctc_table);
	sh_css_set_xnr_table(params, &default_xnr_table);
	sh_css_set_anr_thres(params, &default_anr_thres);
	sh_css_set_ecd_config(params, &default_ecd_config);
	sh_css_set_ynr_config(params, &default_ynr_config);
	sh_css_set_fc_config(params, &default_fc_config);
	sh_css_set_cnr_config(params, &default_cnr_config);
	sh_css_set_macc_config(params, &default_macc_config);
	sh_css_set_ctc_config(params, &default_ctc_config);
	sh_css_set_aa_config(params, &default_aa_config);
	sh_css_set_r_gamma_table(params, &default_r_gamma_table);
	sh_css_set_g_gamma_table(params, &default_g_gamma_table);
	sh_css_set_b_gamma_table(params, &default_b_gamma_table);
	sh_css_set_yuv2rgb_cc_config(params, &default_yuv2rgb_cc_config);
	sh_css_set_rgb2yuv_cc_config(params, &default_rgb2yuv_cc_config);
	sh_css_set_dz_config(params, &default_dz_config);
	for (i = 0; i < N_GDC_ID; i++)
		gdc_lut_store((gdc_ID_t)i, zoom_table);
	params->fpn_table.data = NULL;
	params->fpn_table_changed = true;
	params->isp_parameters.fpn_enabled = 0;
	params->morph_table = NULL;
	params->morph_table_changed = true;
	params->sc_table = NULL;
	params->sc_table_changed = true;
	params->motion_config = default_motion_config;
	params->motion_config_changed = true;
	params->dvs2_hor_coefs.odd_real = NULL;
	params->dvs2_hor_coefs.odd_imag = NULL;
	params->dvs2_hor_coefs.even_real = NULL;
	params->dvs2_hor_coefs.even_imag = NULL;
	params->dvs2_ver_coefs.odd_real = NULL;
	params->dvs2_ver_coefs.odd_imag = NULL;
	params->dvs2_ver_coefs.even_real = NULL;
	params->dvs2_ver_coefs.even_imag = NULL;
	params->dvs2_coef_table_changed = true;
	
	/*Initialise and generate table later in star*/
	params->dvs_6axis_config = NULL;
	params->dvs_6axis_config_changed = true; 

	/* now commit to ddr */
	sh_css_param_update_isp_params(stream, false);
 
	/* create per pipe reference to general ddr_ptrs */
	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++) {
		ref_sh_css_ddr_address_map(ddr_ptrs, &params->pipe_ddr_ptrs[i]);
		params->pipe_ddr_ptrs_size[i] = *ddr_ptrs_size;
	}

	sh_css_dtrace(SH_DBG_TRACE,
		"sh_css_params_init() leave: "
		"return_err=%d\n",IA_CSS_SUCCESS);

	return IA_CSS_SUCCESS;
}

enum ia_css_err
sh_css_params_init(void)
{
	int i, p;
	enum ia_css_vamem_type vamem_type;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_init() enter: void\n");

	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++) {
		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
			xmem_sp_stage_ptrs[p][i] =
					sh_css_refcount_retain(-1,
					    mmgr_calloc(1,
					    sizeof(struct sh_css_sp_stage)));
/* MW: memory leak, if you don't want a nice object_free(), then assert */
			if (xmem_sp_stage_ptrs[p][i] == mmgr_NULL)
				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
			xmem_isp_stage_ptrs[p][i] =
					sh_css_refcount_retain(-1,
					    mmgr_calloc(1,
					    sizeof(struct sh_css_isp_stage)));
/* MW: memory leak, if you don't want a nice object_free(), then assert */
			if (xmem_isp_stage_ptrs[p][i] == mmgr_NULL)
				return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
		}
	}

	/* We need to use memcpy to initialize the default tables
	 * because we cannot initialize union fields in C89. */
#if defined(HAS_VAMEM_VERSION_2)
	vamem_type = IA_CSS_VAMEM_TYPE_2;
	memcpy(default_gamma_table.data.vamem_2, default_gamma_table_data,
	       sizeof(default_gamma_table_data));
	memcpy(default_ctc_table.data.vamem_2, default_ctc_table_data,
	       sizeof(default_ctc_table_data));
	memcpy(default_xnr_table.data.vamem_2, default_xnr_table_data,
	       sizeof(default_xnr_table_data));
	memcpy(default_r_gamma_table.data.vamem_2, default_r_gamma_table_data,
	       sizeof(default_r_gamma_table_data));
	memcpy(default_g_gamma_table.data.vamem_2, default_g_gamma_table_data,
	       sizeof(default_g_gamma_table_data));
	memcpy(default_b_gamma_table.data.vamem_2, default_b_gamma_table_data,
	       sizeof(default_b_gamma_table_data));
#else
	vamem_type = IA_CSS_VAMEM_TYPE_1;
	memcpy(default_gamma_table.data.vamem_1, default_gamma_table_data,
	       sizeof(default_gamma_table_data));
	memcpy(default_ctc_table.data.vamem_1, default_ctc_table_data,
	       sizeof(default_ctc_table_data));
	memcpy(default_xnr_table.data.vamem_1, default_xnr_table_data,
	       sizeof(default_xnr_table_data));
	memcpy(default_r_gamma_table.data.vamem_1, default_r_gamma_table_data,
	       sizeof(default_r_gamma_table_data));
	memcpy(default_g_gamma_table.data.vamem_1, default_g_gamma_table_data,
	       sizeof(default_g_gamma_table_data));
	memcpy(default_b_gamma_table.data.vamem_1, default_b_gamma_table_data,
	       sizeof(default_b_gamma_table_data));
#endif
	default_gamma_table.vamem_type   = vamem_type;
	default_ctc_table.vamem_type     = vamem_type;
	default_xnr_table.vamem_type     = vamem_type;
	default_r_gamma_table.vamem_type = vamem_type;
	default_g_gamma_table.vamem_type = vamem_type;
	default_b_gamma_table.vamem_type = vamem_type;

	sp_ddr_ptrs = sh_css_refcount_retain(-1, mmgr_calloc(1,
		CEIL_MUL(sizeof(struct sh_css_ddr_address_map),
			 HIVE_ISP_DDR_WORD_BYTES)));
	xmem_sp_group_ptrs = sh_css_refcount_retain(-1, mmgr_calloc(1,
		sizeof(struct sh_css_sp_group)));

	if ((sp_ddr_ptrs == mmgr_NULL) ||
	    (xmem_sp_group_ptrs == mmgr_NULL)) {
		ia_css_uninit();
		return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
	}
	return IA_CSS_SUCCESS;
}

void sh_css_params_reconfigure_gdc_lut(void)
{
	unsigned i;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_reconfigure_gdc_lut() enter: void\n");

	for (i = 0; i < N_GDC_ID; i++)
		gdc_lut_store(GDC0_ID, zoom_table);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_reconfigure_gdc_lut() leave: return_void\n");
}

static void free_map_callback(
	hrt_vaddress ptr)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map_callback() enter:\n");

	free_sh_css_ddr_address_map(ptr);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map_callback() leave:\n");
}

static void free_buffer_callback(
	hrt_vaddress ptr)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_buffer_callback() enter:\n");

	mmgr_free(ptr);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_buffer_callback() leave:\n");
}

void
sh_css_param_clear_param_sets(void)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() enter:\n");

	sh_css_refcount_clear(PARAM_SET_POOL, &free_map_callback);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_clear_param_sets() leave:\n");
}

/*
 * MW: we can define mmgr_free() to return a NULL
 * then you can write ptr = mmgr_free(ptr);
 */
#define safe_free(id, x)      \
	do {                  \
		sh_css_refcount_release(id, x);     \
		(x) = mmgr_NULL;  \
	} while (0)

static void free_map(struct sh_css_ddr_address_map *map)
{
	unsigned int i;

	hrt_vaddress *addrs = (hrt_vaddress *)map;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map() enter:\n");

	/* free buffers */
	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
						sizeof(size_t)); i++) {
		if (addrs[i] == mmgr_NULL)
			continue;
		safe_free(PARAM_BUFFER, addrs[i]);
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_map() leave:\n");
}

void
ia_css_stream_isp_parameters_uninit(struct ia_css_stream *stream)
{
	int i;
	struct ia_css_isp_parameters *params = stream->isp_params_configs;

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_isp_parameters_uninit() enter\n");
	/* free existing ddr_ptr maps */
	for (i = 0; i < IA_CSS_PIPE_ID_NUM; i++)
		free_map(&params->pipe_ddr_ptrs[i]);
	free_map(&params->ddr_ptrs);

	if (params->fpn_table.data)
		sh_css_free(params->fpn_table.data);

	/*Free up theDVS table memory blocks before recomputing new table  */
	if(params->dvs_6axis_config)
		free_dvs_6axis_table(&(params->dvs_6axis_config));
	
	sh_css_free(params);
	sh_css_dtrace(SH_DBG_TRACE, "ia_css_stream_isp_parameters_uninit() leave\n");
}

void
sh_css_params_uninit(void)
{
	unsigned p, i;

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_uninit() enter:\n");

	safe_free(-1, sp_ddr_ptrs);
	safe_free(-1, xmem_sp_group_ptrs);

	for (p = 0; p < IA_CSS_PIPE_ID_NUM; p++)
		for (i = 0; i < SH_CSS_MAX_STAGES; i++) {
			safe_free(-1, xmem_sp_stage_ptrs[p][i]);
			safe_free(-1, xmem_isp_stage_ptrs[p][i]);
		}

	/* go through the pools to clear references */
	sh_css_refcount_clear(PARAM_SET_POOL, &free_map_callback);
	sh_css_refcount_clear(PARAM_BUFFER, &free_buffer_callback);
	sh_css_refcount_clear(-1, &free_buffer_callback);

	sh_css_dtrace(SH_DBG_TRACE, "sh_css_params_uninit() leave: return_void\n");
}

static void write_morph_plane(
	unsigned short *data,
	unsigned int width,
	unsigned int height,
	hrt_vaddress dest,
	unsigned int aligned_width)
{
	unsigned int i, padding, w;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_morph_plane() enter:\n");

	/* currently we don't have morph table interpolation yet,
	 * so we allow a wider table to be used. This will be removed
	 * in the future. */
	if (width > aligned_width) {
		padding = 0;
		w = aligned_width;
	} else {
		padding = aligned_width - width;
		w = width;
	}

	for (i = 0; i < height; i++) {
		mmgr_store(dest, data, w * sizeof(short));
		dest += w * sizeof(short);
		mmgr_clear(dest, padding * sizeof(short));
		dest += padding * sizeof(short);
		data += width;
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_morph_plane() leave:\n");
}

/* Store the DIS coefficients from the 3A library to DDR where the ISP
   will read them from. The ISP works on a grid that can be larger than
   that of the 3a library. If that is the case, we padd the difference
   with zeroes. */
static void store_dis_coefficients(
	struct ia_css_isp_parameters *params,
	const struct sh_css_binary *binary,
	hrt_vaddress ddr_addr_hor,
	hrt_vaddress ddr_addr_ver)
{
	unsigned int hor_num_isp = binary->dis_hor_coef_num_isp,
		     ver_num_isp = binary->dis_ver_coef_num_isp,
		     hor_num_3a  = binary->dis_hor_coef_num_3a,
		     ver_num_3a  = binary->dis_ver_coef_num_3a,
		     hor_padding = hor_num_isp - hor_num_3a,
		     ver_padding = ver_num_isp - ver_num_3a,
		     i;
	const short *hor_ptr_3a = params->dis_hor_coef_tbl,
		*ver_ptr_3a = params->dis_ver_coef_tbl;
	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
		ver_ptr_isp = ddr_addr_ver;

assert(binary != NULL);
assert(ddr_addr_hor != mmgr_NULL);
assert(ddr_addr_ver != mmgr_NULL);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dis_coefficients() enter:\n");

	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
		if (params->dis_hor_coef_tbl != NULL) {
			mmgr_store(hor_ptr_isp,
				hor_ptr_3a, hor_num_3a * sizeof(*hor_ptr_3a));
			hor_ptr_3a  += hor_num_3a;
		} else {
			mmgr_clear(hor_ptr_isp,
				hor_num_3a * sizeof(*hor_ptr_3a));
		}
		hor_ptr_isp += hor_num_3a * sizeof(short);
		mmgr_clear(hor_ptr_isp, hor_padding * sizeof(short));
		hor_ptr_isp += hor_padding * sizeof(short);
	}
	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(binary); i++) {
		if (params->dis_ver_coef_tbl != NULL) {
			mmgr_store(ver_ptr_isp,
				ver_ptr_3a, ver_num_3a * sizeof(*ver_ptr_3a));
			ver_ptr_3a  += ver_num_3a;
		} else {
			mmgr_clear(ver_ptr_isp,
				ver_num_3a * sizeof(*ver_ptr_3a));
		}
		ver_ptr_isp += ver_num_3a * sizeof(short);
		mmgr_clear(ver_ptr_isp, ver_padding * sizeof(short));
		ver_ptr_isp += ver_padding * sizeof(short);
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dis_coefficients() leave:\n");
}

static void storedvs2_coef(const short *ptr_3a, hrt_vaddress ptr_isp, unsigned num_3a, unsigned padding)
{
  if (ptr_3a != NULL) {
    mmgr_store(ptr_isp, ptr_3a, num_3a * sizeof(*ptr_3a));
  } else {
    mmgr_clear(ptr_isp, num_3a * sizeof(*ptr_3a));
  }
  ptr_isp += num_3a * sizeof(short);
  mmgr_clear(ptr_isp, padding * sizeof(short));

}

static void store_dvs2_coefficients(
	struct ia_css_isp_parameters *params,
	const struct sh_css_binary *binary,
	hrt_vaddress ddr_addr_hor,
	hrt_vaddress ddr_addr_ver)
{
	unsigned int hor_num_isp = binary->dis_hor_coef_num_isp,
		     ver_num_isp = binary->dis_ver_coef_num_isp,
		     hor_num_3a  = binary->dis_hor_coef_num_3a,
		     ver_num_3a  = binary->dis_ver_coef_num_3a,
		     hor_padding = hor_num_isp - hor_num_3a,
		     ver_padding = ver_num_isp - ver_num_3a;
	hrt_vaddress hor_ptr_isp = ddr_addr_hor,
		ver_ptr_isp = ddr_addr_ver;

assert(binary != NULL);
assert(ddr_addr_hor != mmgr_NULL);
assert(ddr_addr_ver != mmgr_NULL);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dvs2_coefficients() enter:\n");

  storedvs2_coef(params->dvs2_hor_coefs.odd_real, hor_ptr_isp, hor_num_3a, hor_padding);
  hor_ptr_isp += hor_num_isp * sizeof(short);
  storedvs2_coef(params->dvs2_hor_coefs.odd_imag, hor_ptr_isp, hor_num_3a, hor_padding);
  hor_ptr_isp += hor_num_isp * sizeof(short);
  storedvs2_coef(params->dvs2_hor_coefs.even_real, hor_ptr_isp, hor_num_3a, hor_padding);
  hor_ptr_isp += hor_num_isp * sizeof(short);
  storedvs2_coef(params->dvs2_hor_coefs.even_imag, hor_ptr_isp, hor_num_3a, hor_padding);

  storedvs2_coef(params->dvs2_ver_coefs.odd_real, ver_ptr_isp, ver_num_3a, ver_padding);
  ver_ptr_isp += ver_num_isp * sizeof(short);
  storedvs2_coef(params->dvs2_ver_coefs.odd_imag, ver_ptr_isp, ver_num_3a, ver_padding);
  ver_ptr_isp += ver_num_isp * sizeof(short);
  storedvs2_coef(params->dvs2_ver_coefs.even_real, ver_ptr_isp, ver_num_3a, ver_padding);
  ver_ptr_isp += ver_num_isp * sizeof(short);
  storedvs2_coef(params->dvs2_ver_coefs.even_imag, ver_ptr_isp, ver_num_3a, ver_padding);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "store_dvs2_coefficients() leave:\n");
}

static void sh_css_update_isp_params_to_ddr(
	struct ia_css_isp_parameters *params,
	hrt_vaddress ddr_ptr)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() enter:\n");

	if (SH_CSS_PREVENT_UNINIT_READS) {
		/* ispparm struct is read with DMA which reads
		 * multiples of the DDR word with (32 bytes):
		 * So we pad with zeroes to prevent warnings in csim.
		 */
		unsigned int aligned_width, padding_bytes;
		hrt_vaddress pad_ptr;

		aligned_width = CEIL_MUL(
				  sizeof(struct sh_css_isp_params),
				  HIVE_ISP_DDR_WORD_BYTES);
		padding_bytes = aligned_width -
				sizeof(struct sh_css_isp_params);
		pad_ptr = ddr_ptr +
				sizeof(struct sh_css_isp_params);
		mmgr_clear(pad_ptr, padding_bytes);
	}
	mmgr_store(ddr_ptr,
	     &(params->isp_parameters),
	     sizeof(struct sh_css_isp_params));

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_isp_params_to_ddr() leave:\n");
}

static void sh_css_dequeue_param_buffers(void)
{
	hrt_vaddress cpy;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_dequeue_param_buffers() enter\n");

	/* clean-up old copy */
	while (sp2host_dequeue_buffer(0, 0,
				sh_css_param_buffer_queue,
				&cpy)) {
		/*
		 * Tell the SP which queues are not full,
		 * by sending the software event.
		 */
		sh_css_sp_snd_event(SP_SW_EVENT_ID_2,
				0,
				sh_css_param_buffer_queue,
				0);

		sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
			"sh_css_dequeue_param_buffers: "
			"dequeued param set %x from %d\n",
			cpy, 0);
			sh_css_dtrace(SH_DBG_TRACE_PRIVATE,
				"sh_css_dequeue_param_buffers: "
				"release ref on param set %x\n",
				cpy);
			free_sh_css_ddr_address_map(cpy);
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_dequeue_param_buffers() leave\n");
}

void
sh_css_param_update_isp_params(struct ia_css_stream *stream, bool commit)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	hrt_vaddress cpy;
	int i;
	unsigned int raw_bit_depth = 10;
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	bool	any_cc_config_changed = false;

	raw_bit_depth = ia_css_stream_input_format_bits_per_pixel(stream);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() enter:\n");

	for (i=0;i<N_CSC_KERNEL_PARAM_SET;i++) {
/* */
		any_cc_config_changed = any_cc_config_changed || params->cc_config_changed[i];
	}

	if (params->s3a_config_changed)
		sh_css_process_3a(params, raw_bit_depth);
	if (params->wb_config_changed)
		sh_css_process_wb(params);
	if (any_cc_config_changed)
		sh_css_process_cc(params);
	if (params->tnr_config_changed)
		sh_css_process_tnr(params);
	if (params->ob_config_changed)
		sh_css_process_ob(params, raw_bit_depth);
	if (params->dp_config_changed)
		sh_css_process_dp(params);
	if (params->nr_config_changed || params->ee_config_changed)
		sh_css_process_nr_ee(params);
	if (params->de_config_changed)
		sh_css_process_de(params);
	if (params->gc_config_changed)
		sh_css_process_gc(params);
	if (params->anr_config_changed)
		sh_css_process_anr(params);
	if (params->ce_config_changed)
		sh_css_process_ce(params);
	if (params->ecd_config_changed)
		sh_css_process_ecd(params);
	if (params->ynr_config_changed)
		sh_css_process_ynr(params);
	if (params->fc_config_changed)
		sh_css_process_fc(params);
	if (params->cnr_config_changed)
		sh_css_process_cnr(params);
	if (params->macc_config_changed)
		sh_css_process_macc(params);
	if (params->ctc_config_changed)
		sh_css_process_ctc(params);
	if (params->aa_config_changed)
		sh_css_process_aa(params);
/*
	if (params->yuv2rgb_cc_config_changed)
		sh_css_process_yuv2rgb_cc(params);
	if (params->rgb2yuv_cc_config_changed)
		sh_css_process_rgb2yuv_cc(params);
*/
	/* now make the map available to the sp */
	if (!commit) {
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() leave:\n");
		return;
	}
	/* enqueue a copies of the mem_map to
	   the designated pipelines */
	for (i = 0; i < stream->num_pipes; i++) {
		struct ia_css_pipe *pipe;
		struct sh_css_ddr_address_map *cur_map;
		struct sh_css_ddr_address_map_size *cur_map_size;
		struct sh_css_ddr_address_map tmp_map;
		struct sh_css_ddr_address_map_size tmp_map_size;
		struct sh_css_pipeline *pipeline;
		struct sh_css_pipeline_stage *stage;
		unsigned int thread_id, pipe_num;

		pipe = stream->pipes[i];
		pipeline = ia_css_pipe_get_pipeline(pipe);
		pipe_num = ia_css_pipe_get_pipe_num(pipe);
		sh_css_query_sp_thread_id(pipe_num, &thread_id);

		cur_map = &params->pipe_ddr_ptrs[pipeline->pipe_id];
		cur_map_size = &params->pipe_ddr_ptrs_size[pipeline->pipe_id];

		/* TODO: Normally, zoom and motion parameters shouldn't
		 * be part of "isp_params" as it is resolution/pipe dependant
		 * Therefore, move the zoom config elsewhere (e.g. shading
		 * table can be taken as an example! @GC
		 * */
		if (params->isp_params_changed || params->dz_config_changed ||
				params->motion_config_changed) {
			/* we have to do this per pipeline because */
			/* the processing is a.o. resolution dependent */
			sh_css_process_zoom_and_motion(params,
							pipeline->pipe_id,
							pipeline->stages);
		}

		/* update isp_params to pipe specific copies */
		if (params->isp_params_changed) {
			reallocate_buffer(&cur_map->isp_param,
				  &cur_map_size->isp_param,
				  cur_map_size->isp_param,
				  true,
				  &err);
			sh_css_update_isp_params_to_ddr(params, cur_map->isp_param);
		}
		/* update the other buffers to the pipe specific copies */
		for (stage = pipeline->stages; stage;
			stage = stage->next) {
			if (stage && stage->binary) {
				err =
				  sh_css_params_write_to_ddr_internal(
							params,
							stage->binary,
							cur_map,
							cur_map_size);
				if (err != IA_CSS_SUCCESS)
					break;
			}
		}
		/* last make referenced copy */
		err = ref_sh_css_ddr_address_map(
					cur_map,
					&tmp_map);
		tmp_map_size = *cur_map_size;
		/* now write the copy to ddr */
		write_sh_css_address_map_to_ddr(&tmp_map, &cpy);

		/* enqueue the set to sp */
		if (err == IA_CSS_SUCCESS) {
			bool rc;
			sh_css_dtrace(SH_DBG_TRACE,
				"sh_css_param_update_isp_params: "
				"queue param set %x to %d\n",
				cpy, thread_id);

			rc = host2sp_enqueue_buffer(thread_id, 0,
				sh_css_param_buffer_queue,
				cpy);
			if (!rc) {
				free_sh_css_ddr_address_map(cpy);
			}
			else {
#if 0
				uint32_t tmp[2];
				uint32_t sw_event;

				/* encode the thread ID and the queue ID into the event*/
				tmp[0] = thread_id;
				tmp[1] = sh_css_param_buffer_queue;
				encode_sw_event(tmp, 2, &sw_event);

				/* queue the software event (busy-waiting) */
				while (!host2sp_enqueue_sp_event(sw_event))
					hrt_sleep();
#else
				/*
				 * Tell the SP which queues are not empty,
				 * by sending the software event.
				 */
				sh_css_sp_snd_event(SP_SW_EVENT_ID_1,
						thread_id,
						sh_css_param_buffer_queue,
						0);
#endif

			}
		}
		/* clean-up old copy */
		sh_css_dequeue_param_buffers();
	} /* end for each 'active' pipeline */
	/* clear the changed flags after all params
	   for all pipelines have been updated */
	params->isp_params_changed = false;
	params->fpn_table_changed = false;
	params->dz_config_changed = false;
	params->motion_config_changed = false;
	params->sc_table_changed = false;
	params->ctc_table_changed = false;
	params->xnr_table_changed = false;
	params->anr_thres_changed = false;
	params->gamma_table_changed = false;
	params->macc_table_changed = false;
	params->dis_coef_table_changed = false;
	params->dvs2_coef_table_changed = false;
	params->morph_table_changed = false;
	params->ecd_config_changed = false;
	params->ynr_config_changed = false;
	params->fc_config_changed = false;
	params->cnr_config_changed = false;
	params->macc_config_changed = false;
	params->ctc_config_changed = false;
	params->aa_config_changed = false;
	params->r_gamma_table_changed = false;
	params->g_gamma_table_changed = false;
	params->b_gamma_table_changed = false;
	params->dvs_6axis_config_changed = false;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_param_update_isp_params() leave:\n");
}

static enum ia_css_err sh_css_params_write_to_ddr_internal(
	struct ia_css_isp_parameters *params,
	const struct sh_css_binary *binary,
	struct sh_css_ddr_address_map *ddr_map,
	struct sh_css_ddr_address_map_size *ddr_map_size)
{
	enum ia_css_err err;
	bool buff_realloced;
	/* struct is > 128 bytes so it should not be on stack (see checkpatch) */
	static struct ia_css_macc_table converted_macc_table;

assert(binary != NULL);
assert(ddr_map != NULL);
assert(ddr_map_size != NULL);
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() enter:\n");

	if (binary->info->enable.fpnr) {
		buff_realloced = reallocate_buffer(&ddr_map->fpn_tbl,
			&ddr_map_size->fpn_tbl,
			(size_t)(FPNTBL_BYTES(binary)),
			params->fpn_table_changed,
			&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->fpn_table_changed || buff_realloced) {
			if (params->isp_parameters.fpn_enabled) {
				store_fpntbl(params, ddr_map->fpn_tbl);
			} else if (SH_CSS_PREVENT_UNINIT_READS) {
				hrt_vaddress ptr =
					(hrt_vaddress)ddr_map->fpn_tbl;
				/* prevent warnings when reading fpn table
				 * in csim.*/
				/* Actual values are not used when fpn is
				 * disabled. */
				/* MW: fpn_tbl_size*sizeof(whatever)? */
				mmgr_clear(ptr, ddr_map_size->fpn_tbl);
			}
		}
	}
	if (binary->info->enable.sc) {
		buff_realloced = reallocate_buffer(&ddr_map->sc_tbl,
			&ddr_map_size->sc_tbl,
			(size_t)(SCTBL_BYTES(binary)),
			params->sc_table_changed,
			&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->sc_table_changed || buff_realloced) {
			/* shading table is full resolution, reduce */
			struct ia_css_shading_table *tmp_sc_table;

			prepare_shading_table(
				(const struct ia_css_shading_table *)params->sc_table,
				params->sensor_binning,
				&tmp_sc_table,
				binary);

			store_sctbl(params, binary, ddr_map->sc_tbl, tmp_sc_table);

			ia_css_shading_table_free(tmp_sc_table);
		}
	}

	if (params->ctc_table_changed) {
		reallocate_buffer(&ddr_map->ctc_tbl,
				  &ddr_map_size->ctc_tbl,
				  ddr_map_size->ctc_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->ctc_tbl,
				     &(params->ctc_table.data),
				     ddr_map_size->ctc_tbl);
	}
	if (params->gamma_table_changed) {
		reallocate_buffer(&ddr_map->gamma_tbl,
				  &ddr_map_size->gamma_tbl,
				  ddr_map_size->gamma_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->gamma_tbl,
				     &(params->gamma_table.data),
				     ddr_map_size->gamma_tbl);
	}
	if (params->xnr_table_changed) {
		reallocate_buffer(&ddr_map->xnr_tbl,
				  &ddr_map_size->xnr_tbl,
				  ddr_map_size->xnr_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->xnr_tbl,
				     &(params->xnr_table.data),
				     ddr_map_size->xnr_tbl);
	}
	if (params->anr_thres_changed) {
		reallocate_buffer(&ddr_map->anr_thres,
				  &ddr_map_size->anr_thres,
				  ddr_map_size->anr_thres,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->anr_thres,
				     &(params->anr_thres.data),
				     ddr_map_size->anr_thres);
	}
	if (params->macc_table_changed) {
		unsigned int i, j, idx;
		unsigned int idx_map[] = {
			0, 1, 3, 2, 6, 7, 5, 4, 12, 13, 15, 14, 10, 11, 9, 8};

		for (i = 0; i < IA_CSS_MACC_NUM_AXES; i++) {
			idx = 4*idx_map[i];
			j   = 4*i;

			converted_macc_table.data[idx] =
			    sDIGIT_FITTING(params->macc_table.data[j], 13,
			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
			converted_macc_table.data[idx+1] =
			    sDIGIT_FITTING(params->macc_table.data[j+1], 13,
			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
			converted_macc_table.data[idx+2] =
			    sDIGIT_FITTING(params->macc_table.data[j+2], 13,
			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
			converted_macc_table.data[idx+3] =
			    sDIGIT_FITTING(params->macc_table.data[j+3], 13,
			    SH_CSS_MACC_COEF_SHIFT-params->isp_parameters.exp);
		}
		reallocate_buffer(&ddr_map->macc_tbl,
				  &ddr_map_size->macc_tbl,
				  ddr_map_size->macc_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->macc_tbl,
				     converted_macc_table.data,
				     sizeof(converted_macc_table.data));
	}
	
	if (binary->info->enable.dvs_6axis) {
		buff_realloced = reallocate_buffer(
				&ddr_map->dvs_6axis_params_y,
				&ddr_map_size->dvs_6axis_params_y,
				(size_t)((DVS_6AXIS_BYTES(binary) * 3) / 2), // times 1.5 because UV is packed into the Y plane
				params->dvs_6axis_config_changed,
				&err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (params->dvs_6axis_config_changed || buff_realloced) {
			if(params->dvs_6axis_config == NULL) /* Generate default DVS unity table on start up*/
			{				
				struct ia_css_resolution dvs_offset;
				dvs_offset.width = binary->dvs_envelope.width / 2;
				dvs_offset.height = binary->dvs_envelope.height / 2;

				params->dvs_6axis_config = generate_dvs_6axis_table(&binary->out_frame_info.res,
										    &dvs_offset);
				if(params->dvs_6axis_config == NULL)
					return IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;
			}
			
			store_dvs_6axis_config(params,
						binary,
						ddr_map->dvs_6axis_params_y);
		}
	}

	if (binary->info->enable.dis) {
		buff_realloced = reallocate_buffer(&ddr_map->sdis_hor_coef,
				  &ddr_map_size->sdis_hor_coef,
				  (size_t)(SDIS_HOR_COEF_TBL_BYTES(binary)),
				  params->dis_coef_table_changed,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		buff_realloced |= reallocate_buffer(&ddr_map->sdis_ver_coef,
				  &ddr_map_size->sdis_ver_coef,
				  (size_t)(SDIS_VER_COEF_TBL_BYTES(binary)),
				  params->dis_coef_table_changed,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		if (binary->info->isp_pipe_version == 2) {
			if (params->dvs2_coef_table_changed || buff_realloced) {
				store_dvs2_coefficients(params, binary,
					ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
			}
		} else {
			if (params->dis_coef_table_changed || buff_realloced) {
				store_dis_coefficients(params, binary,
					ddr_map->sdis_hor_coef, ddr_map->sdis_ver_coef);
			}
		}
	}

	if (binary->info->enable.ca_gdc) {
		unsigned int i;
		hrt_vaddress *virt_addr_tetra_x[
			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
			&ddr_map->tetra_r_x,
			&ddr_map->tetra_gr_x,
			&ddr_map->tetra_gb_x,
			&ddr_map->tetra_b_x,
			&ddr_map->tetra_ratb_x,
			&ddr_map->tetra_batr_x
		};
		size_t *virt_size_tetra_x[
			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
			&ddr_map_size->tetra_r_x,
			&ddr_map_size->tetra_gr_x,
			&ddr_map_size->tetra_gb_x,
			&ddr_map_size->tetra_b_x,
			&ddr_map_size->tetra_ratb_x,
			&ddr_map_size->tetra_batr_x
		};
		hrt_vaddress *virt_addr_tetra_y[
			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
			&ddr_map->tetra_r_y,
			&ddr_map->tetra_gr_y,
			&ddr_map->tetra_gb_y,
			&ddr_map->tetra_b_y,
			&ddr_map->tetra_ratb_y,
			&ddr_map->tetra_batr_y
		};
		size_t *virt_size_tetra_y[
			IA_CSS_MORPH_TABLE_NUM_PLANES] = {
			&ddr_map_size->tetra_r_y,
			&ddr_map_size->tetra_gr_y,
			&ddr_map_size->tetra_gb_y,
			&ddr_map_size->tetra_b_y,
			&ddr_map_size->tetra_ratb_y,
			&ddr_map_size->tetra_batr_y
		};
		buff_realloced = false;
		for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
			buff_realloced |=
					reallocate_buffer(virt_addr_tetra_x[i],
						virt_size_tetra_x[i],
						(size_t)
						  (MORPH_PLANE_BYTES(binary)),
						params->morph_table_changed,
						&err);
			if (err != IA_CSS_SUCCESS)
				return err;
			buff_realloced |=
					reallocate_buffer(virt_addr_tetra_y[i],
						virt_size_tetra_y[i],
						(size_t)
						  (MORPH_PLANE_BYTES(binary)),
						params->morph_table_changed,
						&err);
			if (err != IA_CSS_SUCCESS)
				return err;
		}
		if (params->morph_table_changed || buff_realloced) {
			const struct ia_css_morph_table *table = params->morph_table;
			struct ia_css_morph_table *id_table = NULL;

			if ((table != NULL) &&
			    (table->width < binary->morph_tbl_width ||
			     table->height < binary->morph_tbl_height)) {
				table = NULL;
			}
			if (table == NULL) {
				sh_css_params_default_morph_table(&id_table,
								  binary);
				table = id_table;
			}

			for (i = 0; i < IA_CSS_MORPH_TABLE_NUM_PLANES; i++) {
				write_morph_plane(table->coordinates_x[i],
					table->width,
					table->height,
					*virt_addr_tetra_x[i],
					binary->morph_tbl_aligned_width);
				write_morph_plane(table->coordinates_y[i],
					table->width,
					table->height,
					*virt_addr_tetra_y[i],
					binary->morph_tbl_aligned_width);
			}
			if (id_table != NULL)
				ia_css_morph_table_free(id_table);
		}
	}
	if (params->r_gamma_table_changed) {
		reallocate_buffer(&ddr_map->r_gamma_tbl,
				  &ddr_map_size->r_gamma_tbl,
				  ddr_map_size->r_gamma_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->r_gamma_tbl,
				     &(params->r_gamma_table.data),
				     ddr_map_size->r_gamma_tbl);
	}
	if (params->g_gamma_table_changed) {
		reallocate_buffer(&ddr_map->g_gamma_tbl,
				  &ddr_map_size->g_gamma_tbl,
				  ddr_map_size->g_gamma_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->g_gamma_tbl,
				     &(params->g_gamma_table.data),
				     ddr_map_size->g_gamma_tbl);
	}
	if (params->b_gamma_table_changed) {
		reallocate_buffer(&ddr_map->b_gamma_tbl,
				  &ddr_map_size->b_gamma_tbl,
				  ddr_map_size->b_gamma_tbl,
				  true,
				  &err);
		if (err != IA_CSS_SUCCESS)
			return err;
		mmgr_store(ddr_map->b_gamma_tbl,
				     &(params->b_gamma_table.data),
				     ddr_map_size->b_gamma_tbl);
	}
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr_internal() leave:\n");

return IA_CSS_SUCCESS;
}

/**
 * Currently this function is called from:
 *  - sh_css_commit_isp_config
 *    (loops through the stages in a pipe to reconfigure settings)
 */
enum ia_css_err
sh_css_params_write_to_ddr(struct ia_css_stream *stream,
			   const struct sh_css_binary *binary)
{
	int i;
	enum ia_css_err err = IA_CSS_SUCCESS;
	struct ia_css_isp_parameters *params = stream->isp_params_configs;

	assert(binary != NULL);
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() enter:\n");

	for (i = 0; i < stream->num_pipes; i++) {
		struct ia_css_pipe *pipe = stream->pipes[i];
		struct sh_css_pipeline *pipeline;
		pipeline = ia_css_pipe_get_pipeline(pipe);
		err = sh_css_params_write_to_ddr_internal(
				params,
				binary,
				&params->pipe_ddr_ptrs[pipeline->pipe_id],
				&params->pipe_ddr_ptrs_size[pipeline->pipe_id]);
		if (err != IA_CSS_SUCCESS)
			break;
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_params_write_to_ddr() leave:\n");

	return err;
}

const struct ia_css_fpn_table *ia_css_get_fpn_table(struct ia_css_stream *stream)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;	
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_fpn_table() enter & leave:\n");
	return &(params->fpn_table);
}

struct ia_css_shading_table * ia_css_get_shading_table(struct ia_css_stream *stream)
{
	struct ia_css_shading_table *tmp_sc_table = NULL;
	struct sh_css_binary *binary = NULL;
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	int i;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_shading_table() enter:\n");

	for (i = 0; i < stream->num_pipes; i++) {
		struct ia_css_pipe *pipe = stream->pipes[i];
		struct sh_css_pipeline *pipeline;
		struct sh_css_pipeline_stage *stage;
		//unsigned int thread_id;

		pipeline = ia_css_pipe_get_pipeline(pipe);
		assert(pipeline != NULL);

		for (stage = pipeline->stages; stage; stage = stage->next) {
			if (stage && stage->binary) {
				if (stage->binary->info->enable.sc) {
					binary = stage->binary;
					break;
				}
			}
		}
		if (binary)
			break;
	}
	if (binary)
		prepare_shading_table(
			(const struct ia_css_shading_table *)params->sc_table,
			params->sensor_binning,
			&tmp_sc_table,
			binary);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_shading_table() leave:\n");

	return tmp_sc_table;
}

const struct sh_css_isp_params *ia_css_get_isp_params(struct ia_css_stream *stream)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_params() enter & leave:\n");
	return &(params->isp_parameters);
}

void ia_css_get_isp_dis_coefficients(
	struct ia_css_stream *stream,
	short *horizontal_coefficients,
	short *vertical_coefficients)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	unsigned int hor_num_isp, ver_num_isp, i;
	short *hor_ptr = horizontal_coefficients,
	      *ver_ptr = vertical_coefficients;
	hrt_vaddress hor_ptr_isp;
	hrt_vaddress ver_ptr_isp;
	struct sh_css_binary *dvs_binary;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dis_coefficients() enter\n");
	assert(horizontal_coefficients != NULL);
	assert(vertical_coefficients != NULL);

	/* Only video pipe supports DVS */
	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
	dvs_binary = ia_css_stream_get_dvs_binary(stream);
	if (!dvs_binary)
		return;

	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;

	for (i = 0; i < IA_CSS_DVS_NUM_COEF_TYPES; i++) {
		mmgr_load(hor_ptr_isp, hor_ptr, hor_num_isp * sizeof(short));
		hor_ptr_isp += hor_num_isp * sizeof(short);
		hor_ptr     += hor_num_isp;
	}
	for (i = 0; i < SH_CSS_DIS_VER_NUM_COEF_TYPES(dvs_binary); i++) {
		mmgr_load(ver_ptr_isp, ver_ptr, ver_num_isp * sizeof(short));
		ver_ptr_isp += ver_num_isp * sizeof(short);
		ver_ptr     += ver_num_isp;
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dis_coefficients() leave\n");
}

void ia_css_get_isp_dvs2_coefficients(struct ia_css_stream *stream,
	short *hor_coefs_odd_real,
	short *hor_coefs_odd_imag,
	short *hor_coefs_even_real,
	short *hor_coefs_even_imag,
	short *ver_coefs_odd_real,
	short *ver_coefs_odd_imag,
	short *ver_coefs_even_real,
	short *ver_coefs_even_imag)
{
	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	unsigned int hor_num_3a, ver_num_3a;
	unsigned int hor_num_isp, ver_num_isp;
	hrt_vaddress hor_ptr_isp;
	hrt_vaddress ver_ptr_isp;
	struct sh_css_binary *dvs_binary;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dvs2_coefficients() enter\n");
	assert(hor_coefs_odd_real != NULL);
	assert(hor_coefs_odd_imag != NULL);
	assert(hor_coefs_even_real != NULL);
	assert(hor_coefs_even_imag != NULL);
	assert(ver_coefs_odd_real != NULL);
	assert(ver_coefs_odd_imag != NULL);
	assert(ver_coefs_even_real != NULL);
	assert(ver_coefs_even_imag != NULL);

	/* Only video pipe supports DVS */
	hor_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_hor_coef;
	ver_ptr_isp = params->pipe_ddr_ptrs[IA_CSS_PIPE_ID_VIDEO].sdis_ver_coef;
	dvs_binary = ia_css_stream_get_dvs_binary(stream);
	if (!dvs_binary)
		return;

	hor_num_3a  = dvs_binary->dis_hor_coef_num_3a;
	ver_num_3a  = dvs_binary->dis_ver_coef_num_3a;
	hor_num_isp = dvs_binary->dis_hor_coef_num_isp;
	ver_num_isp = dvs_binary->dis_ver_coef_num_isp;

	mmgr_load(hor_ptr_isp, hor_coefs_odd_real, hor_num_3a * sizeof(short));
	hor_ptr_isp += hor_num_isp * sizeof(short);
	mmgr_load(hor_ptr_isp, hor_coefs_odd_imag, hor_num_3a * sizeof(short));
	hor_ptr_isp += hor_num_isp * sizeof(short);
	mmgr_load(hor_ptr_isp, hor_coefs_even_real, hor_num_3a * sizeof(short));
	hor_ptr_isp += hor_num_isp * sizeof(short);
	mmgr_load(hor_ptr_isp, hor_coefs_even_imag, hor_num_3a * sizeof(short));

	mmgr_load(ver_ptr_isp, ver_coefs_odd_real, ver_num_3a * sizeof(short));
	ver_ptr_isp += ver_num_isp * sizeof(short);
	mmgr_load(ver_ptr_isp, ver_coefs_odd_imag, ver_num_3a * sizeof(short));
	ver_ptr_isp += ver_num_isp * sizeof(short);
	mmgr_load(ver_ptr_isp, ver_coefs_even_real, ver_num_3a * sizeof(short));
	ver_ptr_isp += ver_num_isp * sizeof(short);
	mmgr_load(ver_ptr_isp, ver_coefs_even_imag, ver_num_3a * sizeof(short));

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ia_css_get_isp_dvs2_coefficients() leave\n");
}

hrt_vaddress sh_css_store_sp_group_to_ddr(void)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_sp_group_to_ddr() enter & leave:\n");
	mmgr_store(xmem_sp_group_ptrs,
			     &sh_css_sp_group,
			     sizeof(struct sh_css_sp_group));
	return xmem_sp_group_ptrs;
}

hrt_vaddress sh_css_store_sp_stage_to_ddr(
	unsigned pipe,
	unsigned stage)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_sp_stage_to_ddr() enter & leave:\n");
	mmgr_store(xmem_sp_stage_ptrs[pipe][stage],
			     &sh_css_sp_stage,
			     sizeof(struct sh_css_sp_stage));
	return xmem_sp_stage_ptrs[pipe][stage];
}

hrt_vaddress sh_css_store_isp_stage_to_ddr(
	unsigned pipe,
	unsigned stage)
{
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_store_isp_stage_to_ddr() enter & leave:\n");
	mmgr_store(xmem_isp_stage_ptrs[pipe][stage],
			     &sh_css_isp_stage,
			     sizeof(struct sh_css_isp_stage));
	return xmem_isp_stage_ptrs[pipe][stage];
}

static enum ia_css_err ref_sh_css_ddr_address_map(
	struct sh_css_ddr_address_map *map,
	struct sh_css_ddr_address_map *out)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	unsigned int i;

	hrt_vaddress *in_addrs = (hrt_vaddress *)map;
	hrt_vaddress *to_addrs = (hrt_vaddress *)out;

assert(map != NULL);
assert(out != NULL);
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() enter:\n");

	/* copy map using size info */
	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
						sizeof(size_t)); i++) {
		to_addrs[i] = mmgr_NULL;
		if (in_addrs[i] == mmgr_NULL)
			continue;

		to_addrs[i] = sh_css_refcount_retain(PARAM_BUFFER, in_addrs[i]);
	}

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "ref_sh_css_ddr_address_map() leave:\n");

	return err;
}

static enum ia_css_err write_sh_css_address_map_to_ddr(
	struct sh_css_ddr_address_map *me,
	hrt_vaddress *out)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	bool succ;

assert(me != NULL);
assert(out != NULL);
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() enter:\n");

	*out = sh_css_refcount_retain(PARAM_SET_POOL, mmgr_malloc(
				sizeof(struct sh_css_ddr_address_map)));
	succ = (*out != mmgr_NULL);
	if (succ)
		mmgr_store(*out,
			me, sizeof(struct sh_css_ddr_address_map));
	else
		err = IA_CSS_ERR_CANNOT_ALLOCATE_MEMORY;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "write_sh_css_address_map_to_ddr() leave:\n");

	return err;
}

static enum ia_css_err free_sh_css_ddr_address_map(
	hrt_vaddress ptr)
{
	enum ia_css_err err = IA_CSS_SUCCESS;
	struct sh_css_ddr_address_map map;
	unsigned int i;
	hrt_vaddress *addrs = (hrt_vaddress *)&map;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() enter:\n");

	mmgr_load(ptr, &map, sizeof(struct sh_css_ddr_address_map));
	/* copy map using size info */
	for (i = 0; i < (sizeof(struct sh_css_ddr_address_map_size)/
						sizeof(size_t)); i++) {
		if (addrs[i] == mmgr_NULL)
			continue;
		sh_css_refcount_release(PARAM_BUFFER, addrs[i]);
	}
	sh_css_refcount_release(PARAM_SET_POOL, ptr);

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "free_sh_css_ddr_address_map() leave:\n");

	return err;
}

/* Mark all parameters as changed to force recomputing the derived ISP parameters */
void sh_css_invalidate_params(struct ia_css_stream *stream)
{
	int	i;

	struct ia_css_isp_parameters *params = stream->isp_params_configs;
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_invalidate_params() enter:\n");

	params->isp_params_changed = true;
	params->fpn_table_changed = true;
	params->dis_coef_table_changed = true;
	params->dvs2_coef_table_changed = true;
	params->morph_table_changed = true;
	params->sc_table_changed = true;
	params->macc_table_changed = true;
	params->gamma_table_changed = true;
	params->ctc_table_changed = true;
	params->xnr_table_changed = true;
	params->anr_thres_changed = true;
	params->s3a_config_changed = true;
	params->wb_config_changed = true;
	for (i=0;i<N_CSC_KERNEL_PARAM_SET;i++) {
/* */
	params->cc_config_changed[i] = true;
	}
	params->tnr_config_changed = true;
	params->ob_config_changed = true;
	params->dp_config_changed = true;
	params->nr_config_changed = true;
	params->ee_config_changed = true;
	params->de_config_changed = true;
	params->gc_config_changed = true;
	params->anr_config_changed = true;
	params->ce_config_changed = true;
	params->dz_config_changed = true;
	params->motion_config_changed = true;
	
	/*Free up theDVS table memory blocks before recomputing new table  */
	if(params->dvs_6axis_config)
		free_dvs_6axis_table(&(params->dvs_6axis_config));
	params->dvs_6axis_config_changed = true;

	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_invalidate_params() leave:\n");
}

void sh_css_update_uds_and_crop_info(
	const struct ia_css_binary_info *info,
	const struct ia_css_frame_info *in_frame_info,
	const struct ia_css_frame_info *out_frame_info,
	const struct ia_css_resolution *dvs_env,
	bool preview_mode,
	const struct ia_css_dz_config *zoom,
	const struct ia_css_vector *motion_vector,
	struct sh_css_uds_info *uds,		/* out */
	struct sh_css_crop_pos *sp_out_crop_pos)/* out */
{
assert(info != NULL);
assert(in_frame_info != NULL);
assert(out_frame_info != NULL);
assert(dvs_env != NULL);
assert(zoom != NULL);
assert(motion_vector != NULL);
assert(uds != NULL);
assert(sp_out_crop_pos != NULL);
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_uds_and_crop_info() enter:\n");

	if (info->mode == SH_CSS_BINARY_MODE_VF_PP && !preview_mode) {
		/* in non-preview modes, VF_PP does not do
		   the zooming, capture_pp or video do. */
		uds->curr_dx = HRT_GDC_N;
		uds->curr_dy = HRT_GDC_N;
	} else {
		uds->curr_dx   = zoom->dx;
		uds->curr_dy   = zoom->dy;
	}

	if (info->enable.dvs_envelope) {
		unsigned int crop_x = 0,
			     crop_y = 0,
			     uds_xc = 0,
			     uds_yc = 0,
			     env_width, env_height;
		int half_env_x, half_env_y;
		int motion_x = motion_vector->x;
		int motion_y = motion_vector->y;
		bool upscale_x = in_frame_info->res.width < out_frame_info->res.width;
		bool upscale_y = in_frame_info->res.height < out_frame_info->res.height;

		if (info->enable.uds && !info->enable.ds) {
			/**
			 * we calculate with the envelope that we can actually
			 * use, the min dvs envelope is for the filter
			 * initialization.
			 */
			env_width  = dvs_env->width -
					SH_CSS_MIN_DVS_ENVELOPE;
			env_height = dvs_env->height -
					SH_CSS_MIN_DVS_ENVELOPE;
			half_env_x = env_width / 2;
			half_env_y = env_height / 2;
			/**
			 * for digital zoom, we use the dvs envelope and make
			 * sure that we don't include the 8 leftmost pixels or
			 * 8 topmost rows.
			 */
			if (upscale_x) {
				uds_xc = (in_frame_info->res.width
					+ env_width
					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
			} else {
				uds_xc = (out_frame_info->res.width
							+ env_width) / 2
					+ SH_CSS_MIN_DVS_ENVELOPE;
			}
			if (upscale_y) {
				uds_yc = (in_frame_info->res.height
					+ env_height
					+ SH_CSS_MIN_DVS_ENVELOPE) / 2;
			} else {
				uds_yc = (out_frame_info->res.height
							+ env_height) / 2
					+ SH_CSS_MIN_DVS_ENVELOPE;
			}
			/* clip the motion vector to +/- half the envelope */
			motion_x = clamp(motion_x, -half_env_x, half_env_x);
			motion_y = clamp(motion_y, -half_env_y, half_env_y);
			uds_xc += motion_x;
			uds_yc += motion_y;
			/* uds can be pipelined, remove top lines */
			crop_y = 2;
		} else if (info->enable.ds) {
			env_width  = dvs_env->width;
			env_height = dvs_env->height;
			half_env_x = env_width / 2;
			half_env_y = env_height / 2;
			/* clip the motion vector to +/- half the envelope */
			motion_x = clamp(motion_x, -half_env_x, half_env_x);
			motion_y = clamp(motion_y, -half_env_y, half_env_y);
			/* for video with downscaling, the envelope is included
			    in the input resolution. */
			uds_xc = in_frame_info->res.width/2 + motion_x;
			uds_yc = in_frame_info->res.height/2 + motion_y;
			crop_x = info->left_cropping;
			/* ds == 2 (yuv_ds) can be pipelined, remove top
			   lines */
			if (info->enable.ds & 1)
				crop_y = info->top_cropping;
			else
				crop_y = 2;
		} else {
			/* video nodz: here we can only crop. We make sure we
			   crop at least the first 8x8 pixels away. */
			env_width  = dvs_env->width -
					SH_CSS_MIN_DVS_ENVELOPE;
			env_height = dvs_env->height -
					SH_CSS_MIN_DVS_ENVELOPE;
			half_env_x = env_width / 2;
			half_env_y = env_height / 2;
			motion_x = clamp(motion_x, -half_env_x, half_env_x);
			motion_y = clamp(motion_y, -half_env_y, half_env_y);
			crop_x = SH_CSS_MIN_DVS_ENVELOPE
						+ half_env_x + motion_x;
			crop_y = SH_CSS_MIN_DVS_ENVELOPE
						+ half_env_y + motion_y;
		}

		/* Must enforce that the crop position is even */
		crop_x = EVEN_FLOOR(crop_x);
		crop_y = EVEN_FLOOR(crop_y);
		uds_xc = EVEN_FLOOR(uds_xc);
		uds_yc = EVEN_FLOOR(uds_yc);

		uds->xc = uds_xc;
		uds->yc = uds_yc;
		sp_out_crop_pos->x = crop_x;
		sp_out_crop_pos->y = crop_y;
	}
	else {
		/* for down scaling, we always use the center of the image */
		uds->xc = in_frame_info->res.width / 2;
		uds->yc = in_frame_info->res.height / 2;
		sp_out_crop_pos->x = info->left_cropping;
		sp_out_crop_pos->y = info->top_cropping;
	}
	sh_css_dtrace(SH_DBG_TRACE_PRIVATE, "sh_css_update_uds_and_crop_info() leave:\n");
}

struct ia_css_3a_statistics *
ia_css_3a_statistics_allocate(const struct ia_css_3a_grid_info *grid)
{
	struct ia_css_3a_statistics *me;
	int grid_size;

	assert(grid != NULL);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_3a_statistics_allocate() enter: grid=%p\n",grid);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;
	grid_size = grid->width * grid->height;
	me->data = sh_css_malloc(grid_size * sizeof(*me->data));
	if (!me->data)
		goto err;
#if !defined(HAS_NO_HMEM)
	/* No weighted histogram, no structure, treat the histogram data as a byte dump in a byte array */
	me->rgby_data = (struct ia_css_3a_rgby_output *)sh_css_malloc(sizeof_hmem(HMEM0_ID));
#else
	me->rgby_data = NULL;
#endif

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",me);

	return me;
err:
	ia_css_3a_statistics_free(me);

	sh_css_dtrace(SH_DBG_TRACE, "ia_css_3a_statistics_allocate() leave: return=%p\n",NULL);

	return NULL;
}

void
ia_css_3a_statistics_free(struct ia_css_3a_statistics *me)
{
	if (me) {
		sh_css_free(me->rgby_data);
		sh_css_free(me->data);
		sh_css_free(me);
	}
}

struct ia_css_dvs_statistics *
ia_css_dvs_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs_statistics *me;

	assert(grid);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;
	me->hor_proj = sh_css_malloc(grid->height * IA_CSS_DVS_NUM_COEF_TYPES *
					sizeof(*me->hor_proj));
	if (!me->hor_proj)
		goto err;

	me->ver_proj = sh_css_malloc(grid->width * IA_CSS_DVS_NUM_COEF_TYPES *
					sizeof(*me->ver_proj));
	if (!me->ver_proj)
		goto err;

	return me;
err:
	ia_css_dvs_statistics_free(me);
	return NULL;

}

void
ia_css_dvs_statistics_free(struct ia_css_dvs_statistics *me)
{
	if (me) {
		sh_css_free(me->hor_proj);
		sh_css_free(me->ver_proj);
		sh_css_free(me);
	}
}

struct ia_css_dvs_coefficients *
ia_css_dvs_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs_coefficients *me;

	assert(grid);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;

	me->hor_coefs = sh_css_malloc(grid->num_hor_coefs *
				IA_CSS_DVS_NUM_COEF_TYPES *
				sizeof(*me->hor_coefs));
	if (!me->hor_coefs)
		goto err;

	me->ver_coefs = sh_css_malloc(grid->num_ver_coefs *
				IA_CSS_DVS_NUM_COEF_TYPES *
				sizeof(*me->ver_coefs));
	if (!me->ver_coefs)
		goto err;

	return me;
err:
	ia_css_dvs_coefficients_free(me);
	return NULL;
}

void
ia_css_dvs_coefficients_free(struct ia_css_dvs_coefficients *me)
{
	if (me) {
		sh_css_free(me->hor_coefs);
		sh_css_free(me->ver_coefs);
		sh_css_free(me);
	}
}

struct ia_css_dvs2_statistics *
ia_css_dvs2_statistics_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs2_statistics *me;

	assert(grid);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;
	
	me->hor_prod.odd_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.odd_real));
	if (!me->hor_prod.odd_real)
		goto err;

	me->hor_prod.odd_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.odd_imag));
	if (!me->hor_prod.odd_imag)
		goto err;

	me->hor_prod.even_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.even_real));
	if (!me->hor_prod.even_real)
		goto err;

	me->hor_prod.even_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->hor_prod.even_imag));
	if (!me->hor_prod.even_imag)
		goto err;

	me->ver_prod.odd_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.odd_real));
	if (!me->ver_prod.odd_real)
		goto err;

	me->ver_prod.odd_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.odd_imag));
	if (!me->ver_prod.odd_imag)
		goto err;

	me->ver_prod.even_real = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.even_real));
	if (!me->ver_prod.even_real)
		goto err;

	me->ver_prod.even_imag = sh_css_malloc(grid->aligned_width *
		grid->aligned_height * sizeof(*me->ver_prod.even_imag));
	if (!me->ver_prod.even_imag)
		goto err;

	return me;
err:
	ia_css_dvs2_statistics_free(me);
	return NULL;

}

void
ia_css_dvs2_statistics_free(struct ia_css_dvs2_statistics *me)
{
	if (me) {
		sh_css_free(me->hor_prod.odd_real);
		sh_css_free(me->hor_prod.odd_imag);
		sh_css_free(me->hor_prod.even_real);
		sh_css_free(me->hor_prod.even_imag);
		sh_css_free(me->ver_prod.odd_real);
		sh_css_free(me->ver_prod.odd_imag);
		sh_css_free(me->ver_prod.even_real);
		sh_css_free(me->ver_prod.even_imag);
		sh_css_free(me);
	}
}

struct ia_css_dvs2_coefficients *
ia_css_dvs2_coefficients_allocate(const struct ia_css_dvs_grid_info *grid)
{
	struct ia_css_dvs2_coefficients *me;

	assert(grid);

	me = sh_css_calloc(1,sizeof(*me));
	if (!me)
		goto err;

	me->grid = *grid;

	me->hor_coefs.odd_real = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.odd_real));
	if (!me->hor_coefs.odd_real)
		goto err;

	me->hor_coefs.odd_imag = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.odd_imag));
	if (!me->hor_coefs.odd_imag)
		goto err;

	me->hor_coefs.even_real = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.even_real));
	if (!me->hor_coefs.even_real)
		goto err;

	me->hor_coefs.even_imag = sh_css_malloc(grid->num_hor_coefs *
		sizeof(*me->hor_coefs.even_imag));
	if (!me->hor_coefs.even_imag)
		goto err;

	me->ver_coefs.odd_real = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.odd_real));
	if (!me->ver_coefs.odd_real)
		goto err;

	me->ver_coefs.odd_imag = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.odd_imag));
	if (!me->ver_coefs.odd_imag)
		goto err;

	me->ver_coefs.even_real = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.even_real));
	if (!me->ver_coefs.even_real)
		goto err;

	me->ver_coefs.even_imag = sh_css_malloc(grid->num_ver_coefs *
		sizeof(*me->ver_coefs.even_imag));
	if (!me->ver_coefs.even_imag)
		goto err;

	return me;
err:
	ia_css_dvs2_coefficients_free(me);
	return NULL;
}

void
ia_css_dvs2_coefficients_free(struct ia_css_dvs2_coefficients *me)
{
	if (me) {
		sh_css_free(me->hor_coefs.odd_real);
		sh_css_free(me->hor_coefs.odd_imag);
		sh_css_free(me->hor_coefs.even_real);
		sh_css_free(me->hor_coefs.even_imag);
		sh_css_free(me->ver_coefs.odd_real);
		sh_css_free(me->ver_coefs.odd_imag);
		sh_css_free(me->ver_coefs.even_real);
		sh_css_free(me->ver_coefs.even_imag);
		sh_css_free(me);
	}
}
